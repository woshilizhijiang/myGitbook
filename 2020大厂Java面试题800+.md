###  Java 面试题（一）

#### 1、面向对象的特征有哪些方面？

- 抽象：数据抽象、行为抽象
- 继承：从已有类得到继承信息。（父类、子类）
- 封装：封装复杂实现，提供简单编程接口
- 多态性：允许不同子类型的对象对同一消息作出不同的响应。编译时及运行时多态性。

#### 2、访问修饰符 public,private,protected,以及不写（默认）时的区别？

| 属性关键字 | 当前类 | 同包 | 子类 | 其他包 |
| ---------- | ------ | ---- | ---- | ------ |
| public     | ✔      | ✔    | ✔    | ✔      |
| protected  | ✔      | ✔    | ✔    | ×      |
| default    | ✔      | ✔    | ×    | ×      |
| private    | ✔      | ×    | ×    | ×      |

#### ~~3、String 是最基本的数据类型吗？~~

~~基础类型（primitive type）只有8种，剩下都是引用类型（referencetype）；java5引入枚举类型也算比较特殊的引用类型。~~
~~考点：基础类型和引用类型~~



#### 5、short s1 = 1; s1 = s1 + 1;有错吗?short s1 = 1; s1 += 1;有错吗？

类型转换
short s1 = 1; s1 = s1 + 1 错误
short s1 = 1; s1 += 1  正确   **暗含（ s1 = short(s1+1)）**

6、Java 有没有 goto？
没有：但是时java保留字

**7、int 和 Integer 有什么区别？**

```java
//AutoBoxing
//实际相当于：
//Integer total = Integer.valueOf(99)
Integer total = 99;


//UnBoxing
//实际相当于：
//int totalprim = total.intValue()
int i = total;

/**************************************Integer源码分析***************************************************/
包装类
-127～128
IntegerCache
```

8、&和&&的区别？
短路



#### **9、解释内存中的栈(stack)、堆(heap)和方法区(method area)的用法。**



#### 10、Math.round(11.5) 等于多少？Math.round(-11.5)等于多少？

12  -11



**11、switch 是否能作用在 byte 上，是否能作用在 long 上，是否能作用在 String 上？**

jdk1.5前:char  byte  int  short 
jdk1.5:枚举

jdk1.7:字符串（String）

long暂不支持

#### 12、用最有效率的方法计算 2 乘以 8？

考偏移量
n * 31 == n<<5 -n

**13、数组有没有 length()方法？String 有没有 length()方法？**

数组没有 length()方法 ，有 length 的属性。String 有 length()方法。JavaScript中，获得字符串的长度是通过 length 属性得到的，这一点容易和 Java 混淆。





#### 15、构造器（constructor）是否可被重写（override）？

Java 重写(Override)与重载(Overload)区别

重写：

1. **子类覆写父类方法**
2. **运行时加载**

**重载：**

1. **方法名相同，参数个数不同**
2. **编译时加载**



~~16、两个对象值相同(x.equals(y) == true)，但却可有不同的 hashcode，这句话对不对？~~



17~~、是否可以继承 String 类？~~



#### 18、当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递？

java值传递

#### 19、String 和 StringBuilder、StringBuffer 的区别？

final 不可被修改
StringBuilder 可修改、线程不安全
StringBuffer 可修改过、线程安全



20、重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？

override：子类重写父类

overload：方法相同、参数不同；重载与参数类型无关



#### 21、描述一下 JVM 加载 class 文件的原理机制？

隐式：new

显示：class.forname()

类加载机制7步骤

##### 22、char 型变量中能不能存贮一个中文汉字，为什么？

1.java采用unicode编码，2个字节（16位）来表示一个字符， 无论是汉字还是数字，字母，或其他语言都可以存储。 2.char 在java中是2个字节，所以可以存储中文。



23、抽象类（abstract class）和接口（interface）有什么异同？



24、静态嵌套类(Static Nested Class)和内部类（Inner Class）的不同？



25、Java 中会存在内存泄漏吗，请简单描述。



26、抽象的（abstract）方法是否可同时是静态的（static）,是否可同时是本地方法（native），是否可同时被 synchronized 修饰？

27、阐述静态变量和实例变量的区别。

28、是否可以从一个静态（static）方法内部发出对非静态（non-static）方法的调用？



30、GC 是什么？为什么要有 GC？



#### 32 、 接 口 是 否 可 继 承 （ extends ） 接 口 ？ 抽 象 类 是 否 可 实 现（implements）接口？抽象类是否可继承具体类（concrete class）？

不可以

33、一个”.java”源文件中是否可以包含多个类（不是内部类）？有什么限制？

34、Anonymous Inner Class(匿名内部类)是否可以继承其它类？是否可以实现接口？

35、内部类可以引用它的包含类（外部类）的成员吗？有没有什么限制？

#### 36、Java 中的 final 关键字有哪些用法？

类

方法

属性

37、指出下面程序的运行结果

38、数据类型之间的转换：

#### 39、如何实现字符串的反转及替换？

#### 40、怎样将 GB2312 编码的字符串转换为 ISO-8859-1 编码的字符串？

new String（，）

41、日期和时间：

42、打印昨天的当前时刻。

43、比较一下 Java 和 JavaSciprt。

44、什么时候用断言（assert）？

45、Error 和 Exception 有什么区别？

#### 46、try{}里有一个 return 语句，那么紧跟在这个 try 后的 finally{}里的代码会不会被执行，什么时候被执行，在 return 前还是后?

47、Java 语言如何进行异常处理，关键字：throws、throw、try、catch、finally 分别如何使用？

48、运行时异常与受检异常有何异同？

49、列出一些你常见的运行时异常？

#### 50、阐述 final、finally、finalize 的区别。

51、类 ExampleA 继承 Exception，类 ExampleB 继承 ExampleA。



#### 52、List、Set、Map 是否继承自 Collection 接口？

Map不是



53、阐述 ArrayList、Vector、LinkedList 的存储性能和特性。

54、Collection 和 Collections 的区别？

55、List、Map、Set 三个接口存取元素时，各有什么特点？



56、TreeMap 和 TreeSet 在排序时如何比较元素？Collections 工具类中的 sort()方法如何比较元素？

#### 57、Thread 类的 sleep()方法和对象的 wait()方法都可以让线程暂停执行，它们有什么区别?

#### **58、线程的 sleep()方法和 yield()方法有什么区别？**



**59、当一个线程进入一个对象的 synchronized 方法 A 之后，其它线程是否可进入此对象 synchronized 方法 B？**

不可以

重入锁；互斥



#### 60、请说出与线程同步以及线程调度相关的方法。

61、编写多线程程序有几种实现方式？

62、synchronized 关键字的用法？

63、举例说明同步和异步。

64、启动一个线程是调用 run()还是 start()方法？

65、什么是线程池（thread pool）？

66、线程的基本状态以及状态之间的关系？

67、简述 synchronized 和 java.util.concurrent.locks.Lock 的异同？

#### 68、Java 中如何实现序列化，有什么意义？

#### 69、Java 中有几种类型的流？

70、写一个方法，输入一个文件名和一个字符串，统计这个字符串在这个文件中出现的次数。

71、如何用 Java 代码列出一个目录下所有的文件？

72、用 Java 的套接字编程实现一个多线程的回显（echo）服务器。

73、XML 文档定义有几种形式？它们之间有何本质区别？解析 XML文档有哪几种方式？

74、你在项目中哪些地方用到了 XML？



**75、阐述 JDBC 操作数据库的步骤。**

非池化

1.加载驱动

```java
Class.forName("oracle.jdbc.driver.OracleDriver");
```

2.创建连接

```java
Connection con = DriverManager.getConnection("jdbc:oracle:thin:@localhost:1521:orcl","lizhijiang", "1qaz!QAZ");
```

3.创建语句

```java
PrepareStatement ps = con.prepareStatement("select * from temp where sal between ? and ?");
ps.setint(1, 1000);
ps.setint(2, 3000);
```

4.执行语句

```java
ResultSet = ps.executeQuery();
```

5.处理结果

```java
while(rs.next()){
  System.out.println(rs.getint("empno") + " - " + rs.getString("ename"));
}
```

6.关闭资源

```java
finally {
    if(con != null) {
        try {
            con.close();
        }
        catch (SQLException e) {
            e.printStackTrace();
        }
    }
}
```



76、Statement 和 PreparedStatement 有什么区别？哪个性能更好？

**PreparedStatement:预编译、防止SQL注入、参数赋值和定义分离**
**高并发时PreparedStatement预编译 性能更佳**

**77、使用 JDBC 操作数据库时，如何提升读取数据的性能？如何提升更新数据的性能？**
**接口 java.sql.ResultSet的void setFetchSize（int rows） 指定每次抓取记录数据（典型的空间换时间策略）；**

**要提升更新数据的性能可以使用 PreparedStatement 语句构建批处理，将若干 SQL 语句置于一个批处理中执行**



78、在进行数据库编程时，连接池有什么作用？

基于 Java 的开源数据库连接池主要有：C3P0、Proxool、DBCP、BoneCP、Druid 等。


**79、什么是 DAO 模式？**
**Data Access Object**



**80、事务的 ACID 是指什么？**



**81、JDBC 中如何进行事务处理？**

**java.sql.Connection 的setAutoCommit(false)  、rollback()**

**JDBC 3.0 中还引入了Savepoint（保存点）的概念，允许通过代码设置保存点并让事务回滚到指定的保存点。**

**82、JDBC 能否处理 Blob 和 Clob？**

Blob 是指二进制大对象（Binary Large Object），而 Clob 是指大字符对象（Character Large Objec）



83、简述正则表达式及其用途。

84、Java 中是如何支持正则表达式操作的？

**85、获得一个类的类对象有哪些方式？**

**（1）方法 1：类型.class，例如：String.class**

**（2）方法 2：对象.getClass()，例如：”hello”.getClass()**

**（3）方法 3：Class.forName()，例如：Class.forName(“java.lang.String”)**

#### **88、如何通过反射调用对象的方法？**

**方法 1：通过类对象调用 newInstance()方法，例如：String.class.newInstance()**

**方法 2：通过类对象的 getConstructor()或 getDeclaredConstructor()方法获得构造器（Constructor）对象并调用其 newInstance()方法创建对象，例如：String.class.getConstructor(String.class).newInstance(“Hello”);**



89、简述一下面向对象的”六原则一法则”

90、简述一下你了解的设计模式。



91、用 Java 写一个单例类。

92、什么是 UML？

93、UML 中有哪些常用的图？

**94、用 Java 写一个冒泡排序。**



**95、用 Java 写一个折半查找。**





### Java 面试题（二）

#### 1、Java 中能创建 volatile 数组吗？

可以创造，但是由于volatile指向的是数组的地址，而不是数组的内容，这样多线程访问时候无法访问到最新的数组内容，达不到效果

#### 2、volatile 能使得一个非原子操作变成原子操作吗？



3、volatile 修饰符的有过什么实践？



4、volatile 类型变量提供什么保证？



6、你是如何调用 wait（）方法的？使用 if 块还是循环？为什么？

#### 8、什么是 Busy spin？我们为什么要使用它？

**Busy spin 是一种在不释放 CPU 的基础上等待事件的技术**。它经常用于避免丢失 CPU 缓存中的数据（如果线程先暂停，之后在其他CPU上运行就会丢失）。所以，如果你的工作要求低延迟，并且你的线程目前没有任何顺序，这样你就可以通过循环检测队列中的新消息来代替调用 sleep() 或 wait() 方法。它唯一的好处就是你只需等待很短的时间，如几微秒或几纳秒。LMAX 分布式框架是一个高性能线程间通信的库，该库有一个 BusySpinWaitStrategy 类就是基于这个概念实现的，使用 busy spin 循环 EventProcessors 等待屏障



9、Java 中怎么获取一份线程 dump 文件？



#### 11、什么是线程局部变量？

#### 12、用 wait-notify 写一段代码来解决生产者-消费者问题？

#### 13、用 Java 写一个线程安全的单例模式（Singleton）？

#### 14、Java 中 sleep 方法和 wait 方法的区别？

#### 15、什么是不可变对象（immutable object）？Java 中怎么创建一个不可变对象？

16、我们能创建一个包含可变对象的不可变对象吗？

#### 17、Java 中应该使用什么数据类型来代表价格？

DECIMAL和NUMERIC都行

18、怎么将 byte 转换为 String？

19、Java 中怎样将 bytes 转换为 long 类型？

20、我们能将 int 强制转换为 byte 类型的变量吗？如果该值大于byte 类型的范围，将会出现什么现象？

21、存在两个类，B 继承 A ，C 继承 B，我们能将 B 转换为 C 么？如 C = (C) B；

22、哪个类包含 clone 方法？是 Cloneable 还是 Object？

23、Java 中 ++ 操作符是线程安全的吗？

23、不是线程安全的操作。它涉及到多个指令，如读取变量值，增加，然后存储回内存，这个过程可能会出现多个线程交差。

24、a = a + b 与 a += b 的区别

25、我能在不进行强制转换的情况下将一个 double 值赋值给 long类型的变量吗？

26、3*0.1 == 0.3 将会返回什么？true 还是 false？

27、int 和 Integer 哪个会占用更多的内存？

28、为什么 Java 中的 String 是不可变的（Immutable）？

31、64 位 JVM 中，int 的长度是多数？

32、Serial 与 Parallel GC 之间的不同之处？

33、32 位和 64 位的 JVM，int 类型变量的长度是多数？

34、Java 中 WeakReference 与 SoftReference 的区别？

35、WeakHashMap 是怎么工作的？

36、JVM 选项 -XX:+UseCompressedOops 有什么作用？为什么要使用？

37、怎样通过 Java 程序来判断 JVM 是 32 位 还是 64 位？

38、32 位 JVM 和 64 位 JVM 的最大堆内存分别是多数？

39、JRE、JDK、JVM 及 JIT 之间有什么不同？

40、解释 Java 堆空间及 GC？

41、你能保证 GC 执行吗？

42、怎么获取 Java 程序使用的内存？堆使用的百分比？

43、Java 中堆和栈有什么区别？

44、“a==b”和”a.equals(b)”有什么区别？

45、a.hashCode() 有什么用？与 a.equals(b) 有什么关系？

46、final、finalize 和 finally 的不同之处？

47、Java 中的编译期常量是什么？使用它又什么风险？

48、List、Set、Map 和 Queue 之间的区别(答案)

49、poll() 方法和 remove() 方法的区别？

50、Java 中 LinkedHashMap 和 PriorityQueue 的区别是什么？

51、ArrayList 与 LinkedList 的不区别？

52、用哪两种方式来实现集合的排序？

53、Java 中怎么打印数组？

54、Java 中的 LinkedList 是单向链表还是双向链表？

55、Java 中的 TreeMap 是采用什么树实现的？(答案)

56、Hashtable 与 HashMap 有什么不同之处？

57、Java 中的 HashSet，内部是如何工作的？

58、写一段代码在遍历 ArrayList 时移除一个元素？

59、我们能自己写一个容器类，然后使用 for-each 循环码？

60、ArrayList 和 HashMap 的默认大小是多数？

61、有没有可能两个不相等的对象有有相同的 hashcode？

62、两个相同的对象会有不同的的 hash code 吗？

63、我们可以在 hashcode() 中使用随机数字吗？

64、Java 中，Comparator 与 Comparable 有什么不同？

66、在我 Java 程序中，我有三个 socket，我需要多少个线程来处理？

67、Java 中怎么创建 ByteBuffer？

68、Java 中，怎么读写 ByteBuffer ？

69、Java 采用的是大端还是小端？

70、ByteBuffer 中的字节序是什么？

71、Java 中，直接缓冲区与非直接缓冲器有什么区别？

72、Java 中的内存映射缓存区是什么？

73、socket 选项 TCP NO DELAY 是指什么？

74、TCP 协议与 UDP 协议有什么区别？

75、Java 中，ByteBuffer 与 StringBuffer 有什么区别？(答案)

76、Java 中，编写多线程程序的时候你会遵循哪些最佳实践？

77、说出几点 Java 中使用 Collections 的最佳实践

78、说出至少 5 点在 Java 中使用线程的最佳实践。

79、说出 5 条 IO 的最佳实践(答案)

80、列出 5 个应该遵循的 JDBC 最佳实践

81、说出几条 Java 中方法重载的最佳实践？

82、在多线程环境下，SimpleDateFormat 是线程安全的吗？

83、Java 中如何格式化一个日期？如格式化为 ddMMyyyy 的形式？

84、Java 中，怎么在格式化的日期中显示时区？

85、Java 中 java.util.Date 与 java.sql.Date 有什么区别？

86、Java 中，如何计算两个日期之间的差距？

87、Java 中，如何将字符串 YYYYMMDD 转换为日期？

89、如何测试静态方法？(答案)

90、怎么利用 JUnit 来测试一个方法的异常？

91、你使用过哪个单元测试库来测试你的 Java 程序？

92、@Before 和 @BeforeClass 有什么区别？

93、怎么检查一个字符串只包含数字？解决方案

94、Java 中如何利用泛型写一个 LRU 缓存？

95、写一段 Java 程序将 byte 转换为 long？

96、在不使用 StringBuffer 的前提下，怎么反转一个字符串？

97、Java 中，怎么获取一个文件中单词出现的最高频率？

98、如何检查出两个给定的字符串是反序的？

99、Java 中，怎么打印出一个字符串的所有排列？

100、Java 中，怎样才能打印出数组中的重复元素？

101、Java 中如何将字符串转换为整数？

102、在没有使用临时变量的情况如何交换两个整数变量的值？

103、接口是什么？为什么要使用接口而不是直接使用具体类？

104、Java 中，抽象类与接口之间有什么不同？

105、除了单例模式，你在生产环境中还用过什么设计模式？

106、你能解释一下里氏替换原则吗?

107、什么情况下会违反迪米特法则？为什么会有这个问题？

108、适配器模式是什么？什么时候使用？

109、什么是“依赖注入”和“控制反转”？为什么有人使用？

110、抽象类是什么？它与接口有什么区别？你为什么要使用过抽象类？

111、构造器注入和 setter 依赖注入，那种方式更好？

112、依赖注入和工程模式之间有什么不同？

113、适配器模式和装饰器模式有什么区别？

114、适配器模式和代理模式之前有什么不同？

115、什么是模板方法模式？

116、什么时候使用访问者模式？

117、什么时候使用组合模式？

118、继承和组合之间有什么不同？

119、描述 Java 中的重载和重写？

120、Java 中，嵌套公共静态类与顶级类有什么不同？

121、 OOP 中的 组合、聚合和关联有什么区别？

122、给我一个符合开闭原则的设计模式的例子？

123、抽象工厂模式和原型模式之间的区别？

125、嵌套静态类与顶级类有什么区别？

126、你能写出一个正则表达式来判断一个字符串是否是一个数字吗？

127、Java 中，受检查异常 和 不受检查异常的区别？

128、Java 中，throw 和 throws 有什么区别

129、Java 中，Serializable 与 Externalizable 的区别？

130、Java 中，DOM 和 SAX 解析器有什么不同？

131、说出 JDK 1.7 中的三个新特性？

132、说出 5 个 JDK 1.8 引入的新特性？

133、Java 中，Maven 和 ANT 有什么区别？



### Java面试（三）



#### DDD分层架构的三种模式

DDD:Domain Driven Design==领域驱动设计

UL和BC：通用语言和限界上下文

##### 四层架构

User Interface

Application

Domain

infrastructure

**五层架构**





### Java面试（四-----BAT 大厂Java 面试题集锦之核心篇附参考答案）

#### java基础

##### 1.什么是字符串常量池？

Java设计者**为String提供了字符串常量池以提高其性能**，那么字符串常量池的具体原理是什么，带着以下三个问题，去理解字符串常量池：

1. 字符串常量池的设计意图是什么？

    **提速；缓存空间换时间；以不可变（final）类为基础，解决数据共享冲突；保持可达性，阻止程序GC回收**

2. 字符串常量池在哪里？

    **jvm方法区**

3. 如何操作字符串常量池？ 

    **String.intern()**

   

##### **2.String为什么是不可变的？**



**什么是不可变对象？**

如果一个对象，在它创建完成之后，不能再改变它的状态，那么这个对象就是不可变的。不能改变状态的意思是，不能改变对象内的成员变量，包括基本数

**String对象是不可变的呢？**

final类

**String源码构成**

```java
public final class String
implements java.io.Serializable, Comparable<String>, CharSequence {
    /** The value is used for character storage. */
    private final char value[];

    /** Cache the hash code for the string */
  private int hash; // 
```

**不可变有什么好处？**

1、多线程下安全性

2、类加载中体现的安全性

3、使用常量池可以节省空间



##### **3.String s = new String("xyz");究竟产生了几个对象，从JVM角度谈谈？**

**2个对象**

String str1 = new String("A"+"B") ; 会创建多少个对象?  **2个对象，编译优化"A"+B" 为"AB"**
String str2 = new String("ABC") + "ABC" ; 会创建多少个对象? **3个对象**



##### **4.String拼接字符串效率低，你知道原因吗？** 

ASM指令集角度分析

##### **5.你真的了解String的常见API吗？**

抓住String是final类；对旧string的操作获得的新string 皆为新对象。

```java
String是我们开发中使用频率最高的类，它有哪些方法，大家一定不会陌生，例如：

length();//计算字符串的长度

charAt();//截取一个字符

getChars();//截取多个字符

equals();//比较两个字符串

equalsIgnoreCase();//比较两个字符串,忽略大小写

startsWith();//startsWith()方法决定是否以特定字符串开始

endWith();//方法决定是否以特定字符串结束

indexOf();//查找字符或者子串第一次出现的地方。

lastIndexOf();//查找字符或者子串是后一次出现的地方。

substring();//截取字符串

concat();//连接两个字符串

replace();//替换

trim();//去掉起始和结尾的空格

valueOf();//转换为字符串

toLowerCase();//转换为小写

toUpperCase();// 转换为大写
```



##### **6.Java中的subString()真的会引起内存泄露么？**

jdk1.6出现
以后版本不存在OOM



##### **7.浅析Java中的final关键字？**

- **修饰类**，修饰的类无法被继承，例如String类、Math类、Integer类等；
- **修饰方法**，修饰的方法无法被重写；
- **修饰变量**，包括成员变量和局部变量，该变量只能被赋值一次且它的值无法被改变，对于成员变量来讲，我们必须在声明时或者构造方法中对它赋值；



##### **8.浅析Java中的static关键字？**

- static 关键字可以用来修饰：**属性、方法、内部类、代码块**；
- static 修饰的资源属于**类级别**，是全体对象实例共享的资源；
- 使用 static 修饰的属性，**静态属性是在类的加载期间初始化的**，使用**类名.属性**访问



##### 9.浅析Java中的volatile关键字

- volatile能保证内存可见性
- volatile不能保证原子性
- volatile禁止指令重排序

总结：volatile只能保证变量内存可见性，不能保证原子性。volatile解决的是变量在多个线程之间的可见性，而sychronized、Lock解决的是多个线程之间访问资源的同步性。



##### 10.i++是线程安全的吗?   从字节码角度深度解析 i++ 和 ++i 线程安全性原理？

i++不是线程安全的，解决办法使用synchronized关键字或者AtomicXX系列的包装类，或者JDK1.5以后提供的Lock锁;JDK1.8后特定环境LongAdder累加器。

如代码所示：

```java
 @Test
    public void test1(){
        int i = 0;
        int j;
        j = i++;
        //    LINENUMBER 14 L1
        //    ILOAD 1  //将指定的 int 型局部变量推送至栈顶
        //    IINC 1 1 //IINC M N（M 为非负整数，N 为整数）将局部变量数组的第 M 个单元中的 int 值增加 N，常用于 for 循环中自增量的更新
        //    ISTORE 2
        System.out.println(j);
    }

    /**
     * ++i
     */
    @Test
    public void test2(){
        int i = 0;
        int j;
        //    LINENUMBER 33 L1
        //    IINC 1 1  //IINC M N（M 为非负整数，N 为整数）将局部变量数组的第 M 个单元中的 int 值增加 N，常用于 for 循环中自增量的更新
        //    ILOAD 1   //将指定的 int 型局部变量推送至栈顶
        //    ISTORE 2  //将栈顶 int 型数值存入指定局部变量
        j = ++i;
        System.out.println(j);
    }
```

总结：

i++和++i字节码层面不同只是iload和iinc顺序相反，性能一样；线程不安全

```
//    ILOAD 1 //将指定的 int 型局部变量推送至栈顶
//    IINC 1 1 //IINC M N（M 为非负整数，N 为整数）将局部变量数组的第 M 个单元中的 int 值增加 N，常用于 for 循环中自增量的更新
```



##### 11.请谈谈什么是CAS？

CAS(Compare And Set)算法是硬件对于并发操作的支持，是一种**无锁的非阻塞算法**的实现。**CAS算法保证同时访问时只有一个线程**能进来，当多个线程同时并发访问操作共享数据的时候，有且只有一个能够成功，其他的线程都会失败。CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。

当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。**类似于乐观锁**。

**如失败，会自旋；多用于并发不是特别高的场景。**



##### 12.从源码角度彻底搞懂ArrayList 和LinkedList

**ArrayList**

1. 快速随机访问

2. 允许存放多个null元素

3. 底层是Object数组

4. 增加元素个数可能很慢(可能需要扩容),删除元素可能很慢(可能需要移动很多元素),改对应索引元素比较快

   

   **底层是Object数组存储数据**
   **扩容机制:默认大小是10,扩容是扩容到之前的1.5倍的大小,每次扩容都是将原数组的数据复制进新数组中**. 

   我的领悟:如果是已经知道了需要创建多少个元素,那么尽量用new ArrayList<>(13)这种明确容量的方式创建ArrayList.避免不必要的浪费.
   **添加:**如果是添加到数组的指定位置,那么可能会挪动大量的数组元素,并且可能会触发扩容机制;如果是添加到末尾的话,那么只可能触发扩容机制.
   **删除:**如果是删除数组指定位置的元素,那么可能会挪动大量的数组元素;如果是删除末尾元素的话,那么代价是最小的. ArrayList里面的删除元素,其实是将该元素置为null.
   查询和改某个位置的元素是非常快的( O(1) ).

```java
 private void grow(int minCapacity) {
        // overflow-conscious code
        int oldCapacity = elementData.length;
        int newCapacity = oldCapacity + (oldCapacity >> 1);  //1.5倍扩容
        if (newCapacity - minCapacity < 0)
            newCapacity = minCapacity;
        if (newCapacity - MAX_ARRAY_SIZE > 0)
            newCapacity = hugeCapacity(minCapacity);
        // minCapacity is usually close to size, so this is a win:
        elementData = Arrays.copyOf(elementData, newCapacity);
    }
```



**LinkedList**

- LinkedList底层是链表结构

- 插入和删除比较快（O(1)），查询则相对慢一些（O(n)）

- 因为是链表结构，所以分配的空间不要求是连续的

  **底层是双向链表存储数据,并且记录了头节点和尾节点**
  添加元素非常快,如果是添加到头部和尾部的话更快,因为已经记录了头节点和尾节点,只需要链接一下就行了. 如果是添加到链表的中间部分的话,那么多一步操作,需要先找到添加索引处的元素(因为需要链接到这里),才能进行添加.

  遍历的时候,建议采用forEach()进行遍历,这样可以在每次获取下一个元素时都非常轻松(next = next.next;). 然后如果是通过fori和get(i)的方式进行遍历的话,效率是极低的,每次get(i)都需要从最前面(或者最后面)开始往后查找i索引处的元素,效率很低.
  删除也是非常快,只需要改动一下指针就行了,代价很小.



##### **13.java中方法的参数传递机制**

**问：当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递? 
**　　答:是值传递。**Java 编程语言只有值传递参数**。当一个**对象实例**作为一个参数被传递到方法中时，**参数的值就是该对象的引用一个副本**。指向同一个对象,对象的内容可以在被调用的方法中改变，但对象的引用(不是引用的副本)是永远不会改变的。

　　**Java参数，不管是原始类型还是引用类型，传递的都是副本**(有另外一种说法是**传值**，但是说传副本更好理解吧，传值通常是相对传址而言)。

　　**如果参数类型是原始类型，那么传过来的就是这个参数的一个副本，也就是这个原始参数的值，这个跟之前所谈的传值是一样的。如果在函数中改变了副本的值不会改变原始的值.**

　　**如果参数类型是引用类型，那么传过来的就是这个引用参数的副本，这个副本存放的是参数的地址**。如果在函数中没有改变这个副本的地址，而是改变了地址中的值，那么在函数内的改变会影响到传入的参数。如果在函数中改变了副本的地址，如new一个，那么副本就指向了一个新的地址，此时传入的参数还是指向原来的 地址，所以不会改变参数的值。



##### **14.java中throw和throws的区别？**

**throw语句用在方法体内，表示抛出异常，由方法体内的语句处理。**
**throws语句用在方法声明后面，表示抛出异常，由该方法的调用者来处理。**

throws主要是声明这个方法会抛出这种类型的异常，使它的调用者知道要捕获这个异常。
throw是当程序出现某种逻辑错误时由程序员主动抛出某种特定类型的异常是，具体向外抛异常的动作，所以它是抛出一个异常实例。

throw与throws的比较
1、throws出现在方法函数头；而throw出现在函数体。
2、throws表示出现异常的一种可能性，并不一定会发生这些异常；throw则是抛出了异常，执行throw则一定抛出了某种异常对象。
3、两者都是消极处理异常的方式（这里的消极并不是说这种方式不好），只是抛出或者可能抛出异常，但是不会由函数去处理异常，真正的处理异常由函数的上层调用处理。

##### 15.finally语句块你踩过哪些坑？

finally

{return;}

##### 16.为什么重写equals方法需同时重写hashCode方法

重写equals()方法同时重写hashcode()方法，就是为了保证当两个对象通过equals()方法比较相等时，那么他们的hashCode值也一定要保证相等。



##### 17.equals() 与 == 的区别？

功能不同

"=="是判断两个变量或实例是不是指向同一个内存空间。

"equals"是判断两个变量或实例所指向的内存空间的值是不是相同。

定义不同

"equals"在JAVA中是一个方法。

"=="在JAVA中只是一个运算符合。



##### 18.StringBuffer和StringBuilder的区别，从源码角度分析?

- StringBuffer和StringBuilder都继承自抽象类AbstractStringBuilder。
- 存储数据的字符数组也没有**被final修饰**，说明值可以改变，且构造出来的字符串还有空余位置拼接字符串，但是拼接下去肯定也有不够用的时候，这时候它们内部都提供了一个**自动扩容机制，当发现长度不够的时候(默认长度是16)**，会自动进行扩容工作，**扩展为原数组长度的2倍加2**，创建一个新的数组，并将数组的数据复制到新数组，所以对于拼接字符串效率要比String要高。自动扩容机制是在抽象类中实现的。
- 线程安全性：StringBuffer效率低，线程安全，因为StringBuffer中很多方法都被 synchronized 修饰了，多线程访问时，线程安全，但是效率低下，因为它有加锁和释放锁的过程。StringBuilder效率高，但是线程是不安全的。

```java
 java.lang.AbstractStringBuilder
 //扩容机制
 private int newCapacity(int minCapacity) {
        // overflow-conscious code
        int newCapacity = (value.length << 1) + 2; //扩容机制 2倍+2
        if (newCapacity - minCapacity < 0) {
            newCapacity = minCapacity;
        }
        return (newCapacity <= 0 || MAX_ARRAY_SIZE - newCapacity < 0)
            ? hugeCapacity(minCapacity)
            : newCapacity;
    }
```



##### 19.HashMap的数据结构吗?为何HashMap的数组长度一定是2的次幂？

**JDK1.6,1.7 数组 + 链表**

**JDK1.8：HashMap处理“碰撞”增加了红黑树这种数据结构，当碰撞结点较少时，采用链表存储，当较大时（>8个），采用红黑树（特点是查询时间是O（logn））存储（有一个阀值控制，大于阀值(8个)，将链表存储转换成红黑树存储**



要保证初始化时 HashMap 的容量总是 2 的 n 次方，即底层数组的长度总是为 2 的 n 次方。

HashMap的长度为2的幂次方的原因是为了减少Hash碰撞，尽量使Hash算法的结果均匀分布。



带来的问题就是你的HashMap 数组的利用率太低，并且链表可能因为上边的(n - 1) & hash 运算结果碰撞率过高，导致链表太深。(当然jdk 1.8已经在链表数据超过8个以后转换成了红黑树的操作，但那样也很容易造成它们之间的转换时机的提前到来)，所以说HashMap的长度一定是2的次幂，否则会出现性能问题。

##### 20.HashMap何时扩容以及它的扩容机制？

- 在对HashMap进行扩容的时候，HashMap的容量会变为原来的两倍； 
- 扩容是一个特别耗性能的操作，所以在使用HashMap的时候，如果能估算出map的大小，初始化的时候给一个大致的数值，避免map进行频繁的扩容;



##### 21.HashMap的key一般用字符串,能用其他对象吗？

HashMap中的key可以是null，基本数据类型或引用数据类型。为了HashMap的正常使用，**key一般是不可变对象，至少该对象中用于计算hash值的属性要不可变，方可保证HashMap的正常使用。**



##### 22.HashMap的key和value都能为null么?如果key能为null,那么它是怎么样查找值的？

**HashMap对象的key、value值均可为null。**

hashMap是根据key的hashCode来寻找存放位置的，那当key为null时， 怎么存储呢？

在put方法里头，其实第一行就处理了key=null的情况。 


HashTable key不能为空（有判空）

```java
HashTable
public synchronized V put(K key, V value) {
        // Make sure the value is not null
        if (value == null) {
            throw new NullPointerException();
        }

        // Makes sure the key is not already in the hashtable.
        Entry<?,?> tab[] = table;
        int hash = key.hashCode();
        int index = (hash & 0x7FFFFFFF) % tab.length;
        @SuppressWarnings("unchecked")
        Entry<K,V> entry = (Entry<K,V>)tab[index];
        for(; entry != null ; entry = entry.next) {
            if ((entry.hash == hash) && entry.key.equals(key)) {
                V old = entry.value;
                entry.value = value;
                return old;
            }
        }

        addEntry(hash, key, value, index);
        return null;
    }
```



##### 23. Java面试题 从源码角度分析HashSet实现原理？

HashSet实现自set接口，set集合中元素无序且不能重复；

**因为HashSet底层是基于HashMap实现的**，当你new一个HashSet时候，实际上是new了一个map，执行add方法时，实际上调用map的put方法，**value始终是PRESENT**，所以根据HashMap的一个特性: 将一个key-value对放入HashMap中时，首先根据key的hashCode()返回值决定该Entry的存储位置，如果两个key的hash值相同，那么它们的存储位置相同。如果这个两个key的equalus比较返回true。那么新添加的Entry的value会覆盖原来的Entry的value，key不会覆盖。因此,如果向HashSet中添加一个已经存在的元素，新添加的集合元素不会覆盖原来已有的集合元素；



##### **24.HashTable与HashMap的实现原理有什么不同？**

**1.Null Key & Null Value**
HashMap是支持null键和null值的，允许一个null键和多个null值，而HashTable不允许null键值，在遇到null时，会抛出NullPointerException异常。HashMap在实现时对null做了特殊处理，将null的hashCode值定为了0，从而将其存放在哈希表的第0个bucket中。2.实现原理

**2.1数据结构**

HashMap和HashTable都使用哈希表来存储键值对。在数据结构上是基本相同的，都创建了一个继承自Map.Entry的私有的内部类Entry，每一个Entry对象表示存储在哈希表中的一个键值对。

**2.2算法**

HashMap的相关参数

默认的数组初始容量：16

**哈希碰撞**
**当两个key通过hashCode计算相同时，则发生了hash冲突(碰撞)，HashMap解决hash冲突的方式是用链表。**

当发生hash冲突时，则将存放在数组中的Entry设置为新值的next（这里要注意的是，比如A和B都hash后都映射到下标i中，之前已经有A了，当map.put(B)时，将B放到下标i中，A则为B的next，**所以新值存放在数组中，旧值在新值的链表上**）


##### 25.什么是自动拆装箱？





##### 26.String.valueOf和Integer.toString的区别？

 **Integer.toString()方法**

该方法返回指定整数的有符号位的String对象，以10进制字符串形式返回。

String.valueof()方法

不同于Integer.toString(int)，valueof有大量的重载方法，我们一一对其介绍。



##### 27.final finally finalize 区别及用法

**final**

1，final修饰的class，代表不可以继承扩展。

2、final的方法也是不可以重写的。

3、final修饰的变量是不可以修改的。这里所谓的不可修改对于基本类型来来，的确是不可以修改。而对于引用类型来说，只能说不能重新赋值。也就是不能改变引用地址。但是作为引用类型，它内部所包含的内容如果不是final则可以随意修改

**finally**

提到finally，那么try-catch就逃不掉了。finally 则是Java保证重点代码一定要被执行的一种机制。最常用的地方：通过try-catch-finally来进行类似资源释放、保证解锁等动作

**finalize**

设计之初的作用就是：**在GC要回收某个对象时**，让这个对象有底气的大喊一声：“报告，我还能再抢救一下！”。但是也正是因为如此，JVM要对它进行额外处理。**finalize也就成为了CG回收的阻碍者**，**也就会导致这个对象经过多个垃圾收集周期才能被回收。**






#### java多线程

##### 1.线程的生命周期包括哪几个阶段？

6个阶段；根据java.lang.Thread.State

```java
 public enum State {
        /**
         * Thread state for a thread which has not yet started.
         */
        NEW,

        /**
         * Thread state for a runnable thread.  A thread in the runnable
         * state is executing in the Java virtual machine but it may
         * be waiting for other resources from the operating system
         * such as processor.
         */
        RUNNABLE,

        /**
         * Thread state for a thread blocked waiting for a monitor lock.
         * A thread in the blocked state is waiting for a monitor lock
         * to enter a synchronized block/method or
         * reenter a synchronized block/method after calling
         * {@link Object#wait() Object.wait}.
         */
        BLOCKED,

        /**
         * Thread state for a waiting thread.
         * A thread is in the waiting state due to calling one of the
         * following methods:
         * <ul>
         *   <li>{@link Object#wait() Object.wait} with no timeout</li>
         *   <li>{@link #join() Thread.join} with no timeout</li>
         *   <li>{@link LockSupport#park() LockSupport.park}</li>
         * </ul>
         *
         * <p>A thread in the waiting state is waiting for another thread to
         * perform a particular action.
         *
         * For example, a thread that has called <tt>Object.wait()</tt>
         * on an object is waiting for another thread to call
         * <tt>Object.notify()</tt> or <tt>Object.notifyAll()</tt> on
         * that object. A thread that has called <tt>Thread.join()</tt>
         * is waiting for a specified thread to terminate.
         */
        WAITING,

        /**
         * Thread state for a waiting thread with a specified waiting time.
         * A thread is in the timed waiting state due to calling one of
         * the following methods with a specified positive waiting time:
         * <ul>
         *   <li>{@link #sleep Thread.sleep}</li>
         *   <li>{@link Object#wait(long) Object.wait} with timeout</li>
         *   <li>{@link #join(long) Thread.join} with timeout</li>
         *   <li>{@link LockSupport#parkNanos LockSupport.parkNanos}</li>
         *   <li>{@link LockSupport#parkUntil LockSupport.parkUntil}</li>
         * </ul>
         */
        TIMED_WAITING,

        /**
         * Thread state for a terminated thread.
         * The thread has completed execution.
         */
        TERMINATED;
    }
```



##### **2.多线程有几种实现方式？**

**2种方式；实际原理一致**

1. 继承Thread
2. 实现Runnable

##### ~~3.请谈谈什么是进程，什么是线程？~~



##### ~~4.启动线程是用start()方法还是run()方法？~~



##### 5.说说线程安全问题，什么实现线程安全，如何实现线程安全？

1.使用线程安全的类(ConcurrentHashMap，)
2.使用synchronized同步代码块，或者用Lock锁（锁）
3.多线程并发情况下，线程共享的变量改为方法局部级变量（原子类）



1、多线程环境下

2、多个线程共享同一个资源

3、对资源进行非原子性操作



1、synchronized锁（偏向锁，轻量级锁，重量级锁）；Lock锁

2、volatile锁，只能保证线程之间的可见性，但不能保证数据的原子性

3、jdk1.5并发包中提供的Atomic原子类



##### 6.sychronized和Lock的区别？

两者区别：

1.首先synchronized是java内置关键字，在jvm层面，Lock是个java类；

2.**synchronized无法判断是否获取锁的状态，Lock可以判断是否获取到锁；**

3.**synchronized会自动释放锁(a 线程执行完同步代码会释放锁 ；b 线程执行过程中发生异常会释放锁)，Lock需在finally中手工释放锁（unlock()方法释放锁），否则容易造成线程死锁；**

4.用synchronized关键字的两个线程1和线程2，如果当前线程1获得锁，线程2线程等待。如果线程1阻塞，线程2则会一直等待下去，而Lock锁就不一定会等待下去，**如果尝试获取不到锁，线程可以不用一直等待就结束了**；

5.**synchronized的锁可重入、不可中断、非公平，而Lock锁可重入、可判断、可公平（两者皆可）**

6.Lock锁适合大量同步的代码的同步问题，synchronized锁适合代码少量的同步问题。



##### 7.sleep()和wait()的区别？

对于sleep()方法，我们首先要知道该方法是属于Thread类中的。而wait()方法，则是属于Object类中的。

sleep()方法导致了程序暂停执行指定的时间，让出cpu该其他线程，但监控状态依然保持，当指定的时间到了又会自动恢复运行状态。

在调用sleep()方法的过程中，**线程不会释放对象锁**。

而当调用wait()方法的时候，**线程会放弃对象锁**，进入等待此对象的等待锁定池，只有针对此对象调用notify()方法后本线程才进入对象锁定池准备

获取对象锁进入运行状态。

##### 8.深入分析ThreadLocal的实现原理？ ThreadLocal什么时候会出现OOM的情况？为什么？

线程变量
泄漏危险 ThreadLocal.ThreadLocalMap.Entry继承弱引用;key做了；value没有导致泄漏；

泄漏场景：
线程连接池高并发情况下；不停的set，get；导致ThreadLocal.ThreadLocalMap.Entry 的value积压；从而导致内粗

解决办法：

 ThreadLocal set ->get-> remove

```java
static class Entry extends WeakReference<ThreadLocal<?>> {
            /** The value associated with this ThreadLocal. */
            Object value;

            Entry(ThreadLocal<?> k, Object v) {
                super(k);
                value = v;
            }
```



##### 9.你看过AbstractQueuedSynchronizer源码阅读吗，请说说实现原理？

三大核心

1. **state**
2. **控制线程抢锁和配合的FIFO队列**
3. **期望协作工具类去实现获得获取/释放等重要方法**



##### 10.谈谈对synchronized的偏向锁、轻量级锁、重量级锁的理解？



##### 11.通过三种方式实现生产者消费者模式？

1.同步关键字实现： wait/notify

2.锁实现：ReentrantLock Condition

3.阻塞队列实现：LinkedBlockingQueue put，take/poll



##### 12.JVM层面分析sychronized如何保证线程安全的？

指令集：monitor机制
<img src="/Users/lzj11/Library/Application%20Support/typora-user-images/image-20200427120514497.png" alt="image-20200427120514497" style="zoom:80%;" />

##### 13.JDK层面分析sychronized如何保证线程安全的？



##### 14.如何写一个线程安全的单例？



##### 15.通过AQS实现一个自定义的Lock？





##### 17.为什么wait, notify 和 notifyAll这些方法不在thread类里面？

在java中的wait(),notify()和notifyaAll()是**锁级别的操作**，锁是属于某一个对象的，每一个对象的**对象头中都是含有几位用来保存锁的状态**的，所以这个锁实际上是绑定在某一对象中，而并不是线程中。同样道理我们反过来想假设定义这几个方法在线程中，就会造成很大的局限性。我们经常会遇到某一个线程持有多个锁，并且这些锁之间是相互配合的，如果定义在Thread类里面就没有办法去实现这些灵活的逻辑了。所以Java所提供的原始的锁对于每一个对象都是适用的，他就把这样的方法定义在object里面。



##### 18.你真的理解CountDownLatch与CyclicBarrier使用场景吗？



##### 19.出现死锁，如何排查定位问题？

1.jstack

2.ThreadMCXBean

##### 20.notify和notifyAll的区别？

主要还是考虑到是要唤醒多个线程还是唤醒一个线程



##### 21.线程池启动线程submit和execute有什么不同？

submit返回Future对象

execute无返回



##### 22.SimpleDateFormat是线程安全的吗？如何解决？

1.ThreadLocal
2.jdk1.8 DateTimeFormatter 最终类替换

##### 23.请谈谈ConcurrentHashmap底层实现原理？



##### 24.使用synchronized修饰静态方法和非静态方法有什么区别？



##### 25.当一个线程进入一个对象的一个synchronized方法后,其它线程是否可进入此对象的其方法？

不能，一个对象的一个synchronized方法只能由一个线程访问。 

对象的synchronized方法不能进入了，但它的其他非synchronized方法还是可以访问的。



##### 26.线程池的原理，为什么要创建线程池？创建线程池的方式？



##### 27.创建线程池有哪几个核心参数？ 如何合理配置线程池的大小？

**corePoolSize**

表示常驻核心线程数量。

**maximumPoolSize**

表示线程池中能同时执行的最大线程数量。这个值必须大于等于corePoolSize，如果这两个值相等，那就是固定大小的线程池

**keepAliveTime**

表示线程池中除常驻核心线程之外的其他线程的空闲时间，如果超过这个时间就会销毁。

**TimeUnti**

表示**keepAliveTime**单位

**queue**

缓存队列，当请求的线程数大于corePoolSize的时候，线程会进入队列进行阻塞。当这个队列达到上限之后，线程池会创建新的线程，直到到吗maximumPoolSize大小位置。

**threadFactory**

表示线程工厂。他用来生产一组相同任务的线程。



**RejectedExecutionHandler**

表示拒绝策略。当queue满了之后，并行活动的线程数大于maximunPoolSize的时候，线程池通过改策略处理请求。

其中**RejectedExcutionHandler默认包含四种策略**：

| AbortPolicy(默认)   | 丢弃这个任务并抛出 RejectedExecutionException异常          |
| ------------------- | ---------------------------------------------------------- |
| DiscardPolicy       | **丢弃掉这个任务，但是不抛出异常**                         |
| DiscardOldestPolicy | **抛弃掉在队列中等待最久的任务，然后把当前任务加入队列中** |
| CallerRunsPolicy    | **调用任务的run（）方法绕过线程池直接执行**                |

```java
public static class AbortPolicy implements RejectedExecutionHandler {
        /**
         * Creates an {@code AbortPolicy}.
         */
        public AbortPolicy() { }

        /**
         * Always throws RejectedExecutionException.
         *
         * @param r the runnable task requested to be executed
         * @param e the executor attempting to execute this task
         * @throws RejectedExecutionException always
         */
        public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {
            throw new RejectedExecutionException("Task " + r.toString() +
                                                 " rejected from " +
                                                 e.toString());
        }
    }

public static class DiscardPolicy implements RejectedExecutionHandler {
        /**
         * Creates a {@code DiscardPolicy}.
         */
        public DiscardPolicy() { }

        /**
         * Does nothing, which has the effect of discarding task r.
         *
         * @param r the runnable task requested to be executed
         * @param e the executor attempting to execute this task
         */
        public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {
        }
    }

 public static class DiscardOldestPolicy implements RejectedExecutionHandler {
        /**
         * Creates a {@code DiscardOldestPolicy} for the given executor.
         */
        public DiscardOldestPolicy() { }

        /**
         * Obtains and ignores the next task that the executor
         * would otherwise execute, if one is immediately available,
         * and then retries execution of task r, unless the executor
         * is shut down, in which case task r is instead discarded.
         *
         * @param r the runnable task requested to be executed
         * @param e the executor attempting to execute this task
         */
        public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {
            if (!e.isShutdown()) {
                e.getQueue().poll();
                e.execute(r);
            }
        }
    }

public static class CallerRunsPolicy implements RejectedExecutionHandler {
        /**
         * Creates a {@code CallerRunsPolicy}.
         */
        public CallerRunsPolicy() { }

        /**
         * Executes task r in the caller's thread, unless the executor
         * has been shut down, in which case the task is discarded.
         *
         * @param r the runnable task requested to be executed
         * @param e the executor attempting to execute this task
         */
        public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {
            if (!e.isShutdown()) {
                r.run();
            }
        }
```

另外还支持自定义模式。

public class UserRejectedHandler implements RejectedExecutionHandler {
    @Override
    public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) {
        System.out.println("处理逻辑");
    }
}

##### 28.线程池都有哪几种工作队列

1、ArrayBlockingQueue
是一个基于数组结构的**有界阻塞队列**，此队列按 FIFO（先进先出）原则对元素进行排序。
2、LinkedBlockingQueue
一个基于链表结构的**阻塞队列**，此队列按FIFO （先进先出） 排序元素，吞吐量通常要高于ArrayBlockingQueue。静态工厂方法Executors.newFixedThreadPool()使用了这个队列
3、SynchronousQueue
一个不存储元素的**阻塞队列**。每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockingQueue，静态工厂方法Executors.newCachedThreadPool（5）使用了这个队列。
4、PriorityBlockingQueue
一个具有优先级的**无限阻塞队列**。





#### **Java Web**

什么是Servlet，Servlet生命周期方法？

什么Session和Cookie，它们之间有什么联系？

Http1.0和Http1.1的区别是什么？

拦截器与过滤器的区别？



#### JVM

##### 1.JVM内存区域如何划分？

堆、虚拟机栈、本地方法栈、方法区、程序计数器

##### 2.JVM堆中对象是如何创建的?

1、**当虚拟机遇到new指令（new关键字，反射，clone等）**会触发对象的创建。首先会判断new的对象是否能够在运行时常量池中找到对应类的类名（类的符号引用）

2**、检查类是否被加载、解析和初始化过，如果没有，则执行相应的类加载过程**

3、**为新生对象分配内存，内存的分配方式有两种：指针碰撞、空闲列表**
指针碰撞：
假设Java堆中内存是绝对规整的，所有用过的内存放在一边，空闲的内存在另一边，中间放着一个指针作为分界的指示器，那么当分配内存时仅需移动指针即可。
空闲列表：
维护一个列表，记录那些内存可用，分配时找出一块足够大的空间进行划分，并更新列表记录。

 如果使用的是指针碰撞方法，还需要注意并发情况下，内存的分配是否是线程安全的。一般使用加同步块的方式和本地线程分配缓冲这两种方式解决线程安全的问题。

4、**内存分配完毕后，JVM会对其进行默认初始化（这也是对象的实例变量不需要初始化就可以使用的原因）**

5、从JVM的角度来看，**一个对象就此创建完毕，但是从程序的角度来看，一个对象的创建才刚刚开始，它还没有运行（实例初始化方法），所有的字段都还为默认值。只有运行了之后，一个真正可用的对象才算产生出来。**

<img src="https://img-blog.csdnimg.cn/20200113113725455.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4MTI5MzQwNg==,size_16,color_FFFFFF,t_70" alt="img" style="zoom:80%;" />



##### 3.JVM对象的结构？

在HotSpot虚拟机中，对象在内存中存储的布局可以分为3块区域：**对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）**。下图是普通对象实例与数组对象实例的数据结构：
<img src="https://img-blog.csdn.net/20170419212953720?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvenF6X3pxeg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" style="zoom:67%;" />



**(Header)对象头**
HotSpot虚拟机的对象头包括两部分信息：

**MarkWord**
第一部分markword,**用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等，这部分数据的长度在32位和64位的虚拟机（未开启压缩指针）中分别为32bit和64bit**，官方称它为“MarkWord”。
**klass**
**对象头的另外一部分是klass类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例.**
数组长度（只有数组对象有）
如果对象是一个数组, 那在对象头中还必须有一块数据用于记录数组长度.
(InstanceData)实例数据
   Longs doubles shorts/charts

实例数据部分是对象真正存储的有效信息，也是在程序代码中所定义的各种类型的字段内容。无论是从父类继承下来的，还是在子类中定义的，都需要记录起来。

**(Padding)对齐填充**
**第三部分对齐填充并不是必然存在的，也没有特别的含义，它仅仅起着占位符的作用**。由于HotSpot VM的自动内存管理系统要求对象起始地址必须是8字节的整数倍，换句话说，就是对象的大小必须是8字节的整数倍。而对象头部分正好是8字节的倍数（1倍或者2倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。

对象大小计算
要点

1. 在32位系统下，存放Class指针的空间大小是4字节，MarkWord是4字节，对象头为8字节。
2. 在64位系统下，存放Class指针的空间大小是8字节，MarkWord是8字节，对象头为16字节。
3. 64位开启指针压缩的情况下，存放Class指针的空间大小是4字节，MarkWord是8字节，对象头为12字节。 数组长度4字节+数组对象头8字节(对象引用4字节（未开启指针压缩的64位为8字节）+数组markword为4字节（64位未开启指针压缩的为8字节）)+对齐4=16字节。
4. 静态属性不算在对象大小内。


##### 4.JVM垃圾回收-如何判断对象是否是垃圾对象？

可达性分析法



##### 5.JVM垃圾回收算法有哪些？

<img src="https://pics7.baidu.com/feed/5fdf8db1cb1349542e598558355e2c5cd1094a5f.jpeg?token=218f83050952c04d3f92d3dda8223ef5&amp;s=76B9E76A4102235B4A69373E0200D044" alt="img" style="zoom:67%;" />



**垃圾对象判定标准**

jvm的GC工作主要针对的对象是堆内存，在做GC工作之前，首先要判定堆内存中的对象实例是否为垃圾，通常使用以下两种算法来定义

**1.引用计数算法**

java在运行时，当有一个地方引用该对象实例，会将这个对象实例加1，引用失效时就减1，jvm在扫描内存时，发现引用计数值为0的则是垃圾对象，计数值大于0的则为活跃对象。

目前垃圾回收算法，没有采用引用计数算法，原因是在对象互相引用的情况下，无法判定两者是否为垃圾对象。

**2. 根搜索算法**

根搜索算法是以“GC ROOTS”为起始点往下搜索，所有经过的对象合并起来称为引用链，在这引用链里，没有的对象称为垃圾对象，（实际上jvm还做了一个筛选动作，判定当前对象是否执行finalize()方法，如果不需要执行才判定为垃圾对象，这里不做介绍），在引用链里的是活跃对象。那什么样的对象才能称为“GC ROOTS”呢？以下四种可以

虚拟机栈（栈帧中的本地变量表）中引用的对象。方法区中的类静态属性引用的对象。方法区中的常量引用的对象。本地方法栈中 JNI（Native 方法）的引用对象。**垃圾回收算法**

**1. 标记-清除（Mark-Sweep）**

![img](https://pics7.baidu.com/feed/96dda144ad345982e2eb2f9c6de48fa9cbef8474.jpeg?token=70630aeaf94ebdb90bfc21c329e98b29&s=3A8DB74A4F5636CA5C91C72A02007057)标记清除流程

jvm会扫描所有的对象实例，通过根搜索算法，将活跃对象进行标记，jvm再一次扫描所有对象，将未标记的对象进行清除，只有清除动作，不作任何的处理，这样导致的结果会存在很多的内存碎片。

**2. 复制（copying）**

![img](https://pics3.baidu.com/feed/cdbf6c81800a19d854ca145852ea3c8fa71e46b3.jpeg?token=85f861561616794c19b3e4c2346418a3&s=1E0DA74281A287115CB0C73502002057)复制流程

jvm扫描所有对象，通过根搜索算法标记被引用的对象，之后会申请新的内存空间，将标记的对象复制到新的内存空间里，存活的对象复制完，会清空原来的内存空间，将新的内存最为jvm的对象存储空间。这样虽然解决了内存内存碎片问题，但是如果对象很多，重新申请新的内存空间会很大，在内存不足的场景下，会对jvm运行造成很大的影响

**3. 标记-整理（Mark-compact）**

![img](https://pics2.baidu.com/feed/1ad5ad6eddc451dae5ef6cc2d7edec62d0163296.jpeg?token=ba6c34d81bd5bce554b178cf21b8b8cc&s=FEA9F74A4FD636CA5C99C72A02006057)标记整理流程

标记整理实际上是在标记清除算法上的优化，执行完标记清除全过程之后，再一次对内存进行整理，将所有存活对象统一向一端移动，这样解决了内存碎片问题。

**4. 分代回收**

![img](https://pics4.baidu.com/feed/d788d43f8794a4c2f657f51d6fe4a5d1ad6e39a0.jpeg?token=ef120b2780bb2a13e34554081d75de9a&s=9382F34A3FC81D6444AA4B0B020070D8)分代回收算法

目前jvm常用回收算法就是分代回收，年轻代以复制算法为主，老年代以标记整理算法为主。原因是年轻代对象比较多，每次垃圾回收都有很多的垃圾对象回收，而且要尽可能快的减少生命周期短的对象，存活的对象较少，这时候复制算法比较适合，只要将有标记的对象复制到另一个内存区域，其余全部清除，并且复制的数量较少，效率较高；而老年代是年轻代筛选出来的对象，被标记比较高，需要删除的对象比较少，显然采用标记整理效率较高。





##### 6.JVM垃圾收集器有哪些？



| 收集器            | 串行、并行or并发 | 新生代/老年代 | 算法               | 目标         | 适用场景                                  |
| ----------------- | ---------------- | ------------- | ------------------ | ------------ | ----------------------------------------- |
| Serial            | 串行             | 新生代        | 复制算法           | 响应速度优先 | 单CPU环境下的Client模式                   |
| Serial Old        | 串行             | 老年代        | 标记-整理          | 响应速度优先 | 单CPU环境下的Client模式、CMS的后备预案    |
| ParNew            | 并行             | 新生代        | 复制算法           | 响应速度优先 | 多CPU环境时在Server模式下与CMS配合        |
| Parallel Scavenge | 并行             | 新生代        | 复制算法           | 吞吐量优先   | 在后台运算而不需要太多交互的任务          |
| Parallel Old      | 并行             | 老年代        | 标记-整理          | 吞吐量优先   | 在后台运算而不需要太多交互的任务          |
| CMS               | 并发             | 老年代        | 标记-清除          | 响应速度优先 | 集中在互联网站或B/S系统服务端上的Java应用 |
| G1                | 并发             | both          | 标记-整理+复制算法 | 响应速度优先 | 面向服务端应用，将来替换CMS               |



##### 7.JVM内存是如何分配的？

在虚拟机中，我们知道对象的内存是分配在堆中的。但是堆又可以划分为更小的区域以便垃圾回收，那么，对象到底是怎么在分配在堆中的呢？

  一：**对象优先分配在线程的本地分配缓冲区**

每个线程可以在堆中预先分配得到一片区域，作为**本地线程分配缓冲区（TLAB）**。当该线程执行时，有对象创建的话，就在该线程的TLAB中分配内存。当该线程的TLAB用完了才申请堆中的空闲内存。

  **二：堆中优先分配Eden**

  大多数情况下，对象都在新生代的Eden区中分配内存。而因为大部分的对象都是“朝生夕死”的，所以新生代又会频繁进行垃圾回收。

  **三：大对象直接进入老年代**

  需要大量连续空间的对象，如：长字符串、数组等，会直接在老年代分配内存。这是因为，这样可以避免在新生代区频繁的GC时发生大量的内存赋值（新生代的GC是采用复制算法的）。

  **四：长期存活的对象“晋入”老年代**

  新生代中经历了多次GC仍然存活的对象，当年龄达到一定程度**（默认15）**时就会晋升到老年代。

  为了更好地适应内存情况，虚拟机不是要求对象必须到达阀值才可晋升老年代的，而是采用动态年龄判定的方法：如果Servivor空间中相同年龄的对象大小大于Servivor空间的一般时，由于下一次的MinorGC时，这些对象如果仍然存活的话，复制到ToServivor空间时就放不下了。所以，在本次GC时就可以把这些对象以及年龄大于等于这些对象的直接进入老年代。

  在MinorGC时，如果Eden和FromServivor中存活的对象在复制到ToServivor时放不下了，也会直接分配到老年代。

  **五：空间分配担保**

  在MinorGC之前，会先检查老年代最大可用空间是否可以容纳新生代所有对象（防止新生代全部晋升时放不下），如果可以容纳，则MinorGC可以安全执行。否则，检查是否允许担保失败，是则检查老年代最大可用空间是否大于历次晋升到老年代的对象的平均大小，是则尝试进行MinorGC；小于或者MinorGC失败，则会发起一次FullGC清理老年代。



##### 8.从一道面试题分析类的加载过程？

![img](https://upload-images.jianshu.io/upload_images/6302559-8847214f14181f12?imageMogr2/auto-orient/strip|imageView2/2/w/662/format/webp)


##### 9.JVM双亲委派机制？

1. 首先会先查找当前ClassLoader是否加载过此类，有就返回；
2. 如果没有，查询父ClassLoader是否已经加载过此类，如果已经加载过,就直接返回Parent加载的类；
3. 如果整个类加载器体系上的ClassLoader都没有加载过，才由当前ClassLoader加载(调用findClass)。
   

##### 10.JVM可以作为GC Root的对象有哪些？



**a.** java虚拟机栈中的引用的对象。 

  **b**.方法区中的类静态属性引用的对象。 （一般指被static修饰的对象，加载类的时候就加载到内存中。）

  **c**.方法区中的常量引用的对象。 

  **d**.本地方法栈中的JNI（native方法）引用的对象



##### 11.请写出几段可以导致内存溢出、内存泄漏、栈溢出的代码？





##### 12.哪些情况会导致Full GC？

1. **旧生代空间不足**
旧生代空间只有在新生代对象转入及创建为大对象、大数组时才会出现不足的现象，当执行Full GC后空间仍然不足，则抛出如下错误：
**java.lang.OutOfMemoryError: Java heap space** 
为避免以上两种状况引起的FullGC，调优时应尽量做到让对象在Minor GC阶段被回收、让对象在新生代多存活一段时间及不要创建过大的对象及数组。
2. **Permanet Generation（永久代）空间满**
PermanetGeneration中存放的为一些class的信息等，**当系统中要加载的类、反射的类和调用的方法较多时**，Permanet Generation可能会被占满，在未配置为采用CMS GC的情况下会执行Full GC。如果经过Full GC仍然回收不了，那么JVM会抛出如下错误信息：
**java.lang.OutOfMemoryError: PermGen space** 
为避免Perm Gen占满造成Full GC现象，可采用的方法为增大Perm Gen空间或转为使用CMS GC。
3. **CMS GC时出现promotion failed（担保：s1s2--old）和concurrent mode failure**
对于采用CMS进行旧生代GC的程序而言，尤其要注意GC日志中是否有promotion failed和concurrent mode failure两种状况，当这两种状况出现时可能会触发Full GC。
promotionfailed是在进行Minor GC时，survivor space放不下、对象只能放入旧生代，而此时旧生代也放不下造成的；concurrent mode failure是在执行CMS GC的过程中同时有对象要放入旧生代，而此时旧生代空间不足造成的。
应对措施为：增大survivorspace、旧生代空间或调低触发并发GC的比率，但在JDK 5.0+、6.0+的版本中有可能会由于JDK的bug29导致CMS在remark完毕后很久才触发sweeping动作。对于这种状况，可通过设置-XX:CMSMaxAbortablePrecleanTime=5（单位为ms）来避免。
4. **统计得到的Minor GC晋升到旧生代的平均大小大于旧生代的剩余空间**
这是一个较为复杂的触发情况，Hotspot为了避免由于新生代对象晋升到旧生代导致旧生代空间不足的现象，在进行Minor GC时，做了一个判断，如果之前统计所得到的Minor GC晋升到旧生代的平均大小大于旧生代的剩余空间，那么就直接触发Full GC。
例如程序第一次触发MinorGC后，有6MB的对象晋升到旧生代，那么当下一次Minor GC发生时，首先检查旧生代的剩余空间是否大于6MB，如果小于6MB，则执行Full GC。
当新生代采用PSGC时，方式稍有不同，PS GC是在Minor GC后也会检查，例如上面的例子中第一次Minor GC后，PS GC会检查此时旧生代的剩余空间是否大于6MB，如小于，则触发对旧生代的回收。
除了以上4种状况外，对于使用RMI来进行RPC或管理的Sun JDK应用而言，默认情况下会一小时执行一次Full GC。可通过在启动时通过- java-Dsun.rmi.dgc.client.gcInterval=3600000来设置Full GC执行的间隔时间或通过-XX:+ DisableExplicitGC来禁止RMI调用System.gc。



##### 13.频繁GC问题或内存溢出问题，如何定位？

1.导出整个JVM 中内存信息
jmap -dump:format=b,file=文件名 [pid]

2.分析dump文件的两种方式:
2.1. jdk安装目录下,bin目录下,jvisualvm.exe双击打开 文件–装入–选择dump出来的文件 就可以开始分析了
2.2. 使用eclipse,安装插件mat(MemoryAnalyzerTool)

##### 14.Minor GC触发条件?Full GC触发条件

**Minor GC触发条件**

 1、**eden区满时，触发MinorGC**。即申请一个对象时，发现eden区不够用，则触发一次MinorGC。

   注：新生代分为三个区域，eden space, from space, to space。默认比例是8:1:1。在MinorGC时，会把存活的对象复制到to space区域，如果to space区域不够，则利用担保机制进入老年代区域。

   对eden space, from space, to space的理解：每次分配eden space空间，如果不够，则小于 to space大小的对象复制到 to space，然后to space和from space换位置，所以我们看到的to space一直是空的。
2、Full GC之前调用，仅适用于Parallel Scavenge（-XX:+UseParallelGC），虚拟机运行在Server模式下的默认收集器组合。
   判断一个对象是否存活，除了GC Roots引用之外，还有一个条件就是对象是否重写了finalize方法，如果对象重写了该方法，则会交给FQueue队列去执行，如果执行该方法后被重新关联，则在下次回收时不会被回收，否则下次回收，该方法只执行一次。

**Full GC触发条件**

1、老生代空间不够分配新的内存

2、System.gc()，见Minor GC触发条件的第2点。

3、通过Minor GC后进入老年代的平均大小大于老年代的可用内存。

4、Minor GC时，eden space和from space区大小大于to space且大于老年代内存，触发Full GC。



#### SQL性能优化

数据库三范式是什么？

数据库的事务、ACID及隔离级别？

不考虑事务的隔离性，容易产生哪三种情况？

数据库连接池原理？

什么是B-Tree？

什么是B+Tree？

MySQL数据库索引结构？

什么是索引？什么条件适合建立索引？什么条件不适合建立索引？

索引失效的原因有哪些？如何优化避免索引失效？

MySQL如何启动慢查询日志？

MySQL如何使用show Profile进行SQL分析？

一条执行慢的SQL如何进行优化，如何通过Explain+SQL分析性能？

什么是行锁、表锁、读锁、写锁，说说它们各自的特性？

什么情况下行锁变表锁？

什么情况下会出现间隙锁？

谈谈你对MySQL的in和exists用法的理解？

MySQL的数据库引擎有哪些，如何确定在项目中要是用的存储引擎？

count(*)、count(列名)和count(1)的区别？

union和union all的区别



#### Spring框架

##### 1.Spring的IOC和AOP机制？

**IOC**

 (1). IoC（Inversion of Control）是指**容器控制程序对象之间的关系**，而不是传统实现中，由程序代码直接操控。控制权由应用代码中转到了外部容器，控制权的转移是所谓**反转**。 对于Spring而言，就是由Spring来控制对象的生命周期和对象之间的关系；IoC还有另外一个名字——“依**赖注入（Dependency Injection）**”。从名字上理解，所谓依赖注入，即组件之间的依赖关系由容器在运行期决定，即由容器动态地将某种依赖关系注入到组件之中。  

(2). 在Spring的工作方式中，**所有的类都会在spring容器中登记**，告诉spring这是个什么东西，你需要什么东西，然后spring会在系统运行到适当的时候，把你要的东西主动给你，同时也把你交给其他需要你的东西。所有的类的创建、销毁都由 spring来控制，也就是说控制对象生存周期的不再是引用它的对象，而是spring。对于某个具体的对象而言，以前是它控制其他对象，现在是所有对象都被spring控制，所以这叫控制反转。

(3). 在系统运行中，**动态的向某个对象提供它所需要的其他对象。**  

(4). **依赖注入的思想是通过反射机制实现的**，在实例化一个类时，它通过反射调用类中set方法将事先保存在HashMap中的类属性注入到类中。 总而言之，在传统的对象创建方式中，通常由调用者来创建被调用者的实例，而在Spring中创建被调用者的工作由Spring来完成，然后注入调用者，即所谓的依赖注入or控制反转。 注入方式有两种：依赖注入和设置注入； IoC的优点：降低了组件之间的耦合，降低了业务对象之间替换的复杂性，使之能够灵活的管理对象。



##### 2.Spring中Autowired和Resource关键字的区别？

@Resource和@Autowired都是做bean的注入时使用，其实@Resource并不是Spring的注解，它的包是javax.annotation.Resource，需要导入，但是Spring支持该注解的注入。

1、共同点

两者都可以写在字段和setter方法上。两者如果都写在字段上，那么就不需要再写setter方法。

2、不同点

（1）@Autowired

@Autowired为Spring提供的注解，需要导入包org.springframework.beans.factory.annotation.Autowired;只按照byType注入。

2）@Resource

@Resource默认按照ByName自动注入，由J2EE提供，需要导入包javax.annotation.Resource。@Resource有两个重要的属性：name和type

最好是将@Resource放在setter方法上，因为这样更符合面向对象的思想，通过set、get去操作属性，而不是直接去操作属性。

**@Resource装配顺序**：

**①如果同时指定了name和type，则从Spring上下文中找到唯一匹配的bean进行装配，找不到则抛出异常。**

**②如果指定了name，则从上下文中查找名称（id）匹配的bean进行装配，找不到则抛出异常。**

**③如果指定了type，则从上下文中找到类似匹配的唯一bean进行装配，找不到或是找到多个，都会抛出异常。**

**④如果既没有指定name，又没有指定type，则自动按照byName方式进行装配；如果没有匹配，则回退为一个原始类型进行匹配，如果匹配则自动装配。**

**@Resource的作用相当于@Autowired，只不过@Autowired按照byType自动注入。**

##### 3.依赖注入的方式有几种，各是什么?

1.setter注入 使用setter 方法

2.接口注入 定义接口

3.构造方法 构造方法传参



##### 4.Spring容器对Bean组件是如何管理的？

**1) Bean对象创建的时机**
默认是随着容器创建，可以使用lazy-init=true（在调用getBean创建）延迟创建
也可以用<beans default-lazy-init="true"/>批量延迟创建

**2) Bean对象的创建模式**
默认是单例，可以使用scope属性改变。
singleton:单例，每次调用getBean返回同一个对象
prototype:原型，每次调用getBean返回一个新的对象

**3) Bean对象初始化和销毁**
init-method属性用于指定初始化方法
destroy-method属性用于指定销毁方法，仅适用于singleton模式

**三种实例化bean的方式**
**1.使用类构造器实例化**
<bean id=“UserService" class="com.spring.service.UserService"/>
**2.使用静态工厂方法实例化**
<bean id="UserService" class="com.spring.service.UserFactory" factory-method="createUser"/>

public class UserFactory {
public static UserService createUser(){
return new UserService();
}
}
**3.使用实例工厂方法实例化:**
<bean id="UserServiceFactory" class="com.spring.service.UserFactory"/>
<bean id="UserService" factory-bean="UserServiceFactory" factory-method="createUser"/>
public class UserFactory {
public UserService createUser(){
return new UserService();
}
}

##### 5.Spring容器如何创建？

 **Spring容器的refresh()  创建刷新**

 1 **prepareRefresh() 刷新前的预处理**

   1） initProPertySources（） 初始化一些属性设置； 子类定义个性化的属性设置方法

   2） getEnvironment( ) .validateRequiredProperties() 检验属性的合法性

   3）earlyApplicationEvents = new LinkedHashSet<ApplicationEvent>(); 保存容器中的一些早期的事件

2 **obtainFreshBeanFactory() 获取BeanFactory**

   1）refreshBeanFactory() 刷新(创建) BeanFactory

​        创建了一个this.beanFactory = new DefaultListableBeanFactory()

   2) getBeanFactory() 返回刚才GenericApplicationContext 创建的BeanFactory对象

   3） 将创建的BeanFactory（DefaultListableBeanFactory）返回

3 **prepareBeanFactory(beanFactory); BeanFactory的预准备工作（BeanFactory进行一些设置）** 

   1 设置BeanFactory 的类加载器、支持表达式解析器

   2 添加部分BeanPostProcessor[ApplicationContextAwareProcessor]

  3 设置忽略的自动装配的接口 EnvironmentAware、 EmbeddedValueResolverAware

  4 注册可以解析的自动装配。 直接在任何组件中自动注入： BeanFactory、 ResourceLoader、ApplicationEventPublisher、ApplicationContext

  5 添加BeanPostProcessor【ApplicationListenerDetector功能的Processor】

  6 添加编译时的AspectJ

  7 给BeanFactory中注册有些能用的组件

​      environment【ConfigurableEnvironmetn】

​      systemProperties 【Map<String, Object>】

​       systemEnvironment 【Map<String, Object>】]    

4 **PostProcessoBeanFactory（BeanFactory） BeanFactory准备工作完成后进行的后置处理工作**

 1） 子类通过重写这个方法来在BeanFactory创建并又准备完成以后做进一步的设置

 

到此为止 BeanFactory创建及其预准备工作完成

##### 6.Spring事务分类？



①编程式事务管理使用TransactionTemplate

②声明式事务管理建立在AOP之上的。其本质是通过AOP功能，对方法前后进行拦截，将事务处理的功能编织到拦截的方法中，也就是在目标方法开始之前加入一个事务，在执行完目标方法之后根据执行情况提交或者回滚事务。



##### 7.Spring事务的传播特性？

spring支持7种事务传播行为：

propagation_requierd：如果当前没有事务，就新建一个事务，如果已存在一个事务中，加入到这个事务中，这是最常见的选择。
propagation_supports：支持当前事务，如果没有当前事务，就以非事务方法执行。
propagation_mandatory：使用当前事务，如果没有当前事务，就抛出异常。
propagation_required_new：新建事务，如果当前存在事务，把当前事务挂起。
propagation_not_supported：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。
propagation_never：以非事务方式执行操作，如果当前事务存在则抛出异常。
propagation_nested：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与propagation_required类似的操作

##### 8.Spring事务的隔离级别？

1. **ISOLATION_DEFAULT： 这是一个 PlatfromTransactionManager 默认的隔离级别，使用数据库默认的事务隔离级别**.

 另外四个与 JDBC的隔离级别相对应:

2. **ISOLATION_READ_UNCOMMITTED： 这是事务最低的隔离级别，它允许令外一个事务可以看到这个事务未提交的数据,**

**这种隔离级别会产生脏读，不可重复读和幻像读**。

3. **ISOLATION_READ_COMMITTED： 保证一个事务修改的数据提交后才能被另外一个事务读取。另外一个事务不能读取该事务未提交的数据**

4. **ISOLATION_REPEATABLE_READ： 这种事务隔离级别可以防止脏读，不可重复读。但是可能出现幻像读。它除了保证一个事务不能读取另一个事务未提交的数据外，还保证了避免下面的情况产生(不可重复读)**。

5. **ISOLATION_SERIALIZABLE 这是花费最高代价但是最可靠的事务隔离级别。事务被处理为顺序执行。**

**除了防止脏读，不可重复读外，还避免了幻像读。**



##### 9.Spring的AOP五大通知类型有哪些？

（1）**前置通知（Before advice）**：在某连接点（join point）之前执行的通知，但这个通知不能阻止连接点前的执行（除非它抛出一个异常）。

（2）**返回后通知（After returning advice）**：在某连接点（join point）正常完成后执行的通知：例如，一个方法没有抛出任何异常，正常返回。

（3）**抛出异常后通知（After throwing advice）**：在方法抛出异常退出时执行的通知。

（4）**后通知（After (finally) advice）**：当某连接点退出的时候执行的通知（不论是正常返回还是异常退出）。

（5）**环绕通知（Around Advice）**：包围一个连接点（join point）的通知，如方法调用。这是最强大的一种通知类型。 环绕通知可以在方法调用前后完成自定义的行为。它也会选择是否继续执行连接点或直接返回它们自己的返回值或抛出异常来结束执行。 环绕通知是最常用的一种通知类型。大部分基于拦截的AOP框架，例如Nanning和JBoss4，都只提供环绕通知。



#### SpringMVC框架

SpringMVC完整工作流程，熟读源码流程？

SpringMVC如何处理JSON数据？

SpringMVC拦截器原理，如何自定义拦截器？

SpringMVC如何将请求映射定位到方法上面？结合源码阐述？

SpringMVC常见注解有哪些？

SpringMVC容器和Spring容器的区别？

SpringMVC的控制器是不是单例模式,如果是,有什么问题,怎么解决？



#### MyBatis框架

##### 1.MyBatis中#和$的区别？

**`#`传入的参数在SQL中显示为字符串，`#`方式能够很大程度防止sql注入；**

**`$`传入的参数在SqL中直接显示为传入的值，`$`方式无法防止Sql注入。**

**MyBatis排序时使用order by 动态参数时需要注意，用$而不是#。**



##### 2.MyBatis一级缓存原理以及失效情况？

https://blog.csdn.net/u011277123/article/details/90751348

MyBatis将数据缓存设计成两级结构，分为一级缓存、二级缓存：
一级缓存是Session会话级别的缓存，位于表示一次数据库会话的SqlSession对象之中，又被称之为本地缓存。一级缓存是MyBatis内部实现的一个特性，用户不能配置，默认情况下自动支持的缓存，用户没有定制它的权利（不过这也不是绝对的，可以通过开发插件对它进行修改）；

##### 3.MyBatis二级缓存的使用？

针对查询操作，mybatis支持通过缓存的方式来减少SQL的调用，提高查询性能。在缓存级别方面分为一级缓存和二级缓存，

1. **一级缓存**的粒度较小，是与某个SqlSession绑定的，**只对该SqlSession的相关查询操作进行缓存，**不同SqlSession实例之间相互不影响，缓存为使用本地内存实现；
2. **二级缓存是一种全局缓存，是由所有SqlSession实例所共享的，**即不同SqlSession实例查询时产生的缓存，对其他SqlSession实例可见。

**一级缓存**

- mybatis的一级缓存支持两种缓存级别，分别是SESSION和STATEMENT，默认的一级缓存级别为SESSION。
- **mybatis的一级缓存是默认开启的。**
- 一级缓存的使用示意图如下：(图片引用自：mybatis一级缓存二级缓存）

**二级缓存**

- mybatis默认没有开启二级缓存，**二级缓存支持在配置中自定义底层所用的缓存实现，包括使用本地内存和分布式缓存。**

- 二级缓存是基于namespace的，即作用域为mapper，故需要在每个mapper中配置自身所使用的二级缓存实现以及缓存策略。同时由于二级缓存是基于namespace的，所以不同namespace之间的相互不影响的，如一个namespace使用的本地内存，另外一个namespace使用的是分布式缓存，如果不同namespace对同一张数据表的数据进行了操作，则可能会存在数据不一致问题。

- 如果二级缓存使用本地内存的话，则由于开启二级缓存之后，需要在本地内存缓存大量的数据，即对所有SqlSession实例的查询进行缓存，故可能造成内存资源的开销较大。

- 二级缓存的使用示意图如下：(图片引用自：mybatis一级缓存二级缓存）

  

##### 4.MyBatis拦截器原理？

MyBatis 允许你在已映射语句执行过程中的某一点进行拦截调用。默认情况下，MyBatis 允许使用插件来拦截的方法调用包括：

1. Executor (update, query, flushStatements, commit, rollback, getTransaction, close, isClosed)
2. ParameterHandler (getParameterObject, setParameters)
3. ResultSetHandler (handleResultSets, handleOutputParameters)
4. StatementHandler (prepare, parameterize, batch, update, query)

1. 拦截执行器的方法
2. 拦截参数的处理
3. 拦截结果集的处理
4. 拦截Sql语法构建的处理

##### 5.看过MyBatis源码吗，请说说它的工作流程？



#### Java高级部分

##### 1.Dubbo负载均衡策略？

一致性Hash均衡算法、随机调用法、轮询法、最少活动调用法



**2.Dubbo中Zookeeper做注册中心，如果注册中心集群都挂掉，发布者和订阅者之间还能通信么？**

可以  客户端有本地缓存，

只是无法注册服务、发现服务了。



启动dubbo时，消费者会从zk拉取注册的生产者的地址接口等数据，缓存在本地。每次调用时，按照本地存储的地址进行调用。但是在注册中心全部挂掉后增加新的提供者，则不能被消费者发现：
查看dubbo用户手册（dubbo-user-book）。

健状性
监控中心宕掉不影响使用，只是丢失部分采样数据
数据库宕掉后，注册中心仍能通过缓存提供服务列表查询，但不能注册新服务
注册中心对等集群，任意一台宕掉后，将自动切换到另一台
注册中心全部宕掉后，服务提供者和服务消费者仍能通过本地缓存通讯
服务提供者无状态，任意一台宕掉后，不影响使用
服务提供者全部宕掉后，服务消费者应用将无法使用，并无限次重连等待服务提供者恢复



##### 3.Dubbo完整的一次调用链路介绍？

https://blog.csdn.net/icool_ali/article/details/80985130


##### 4.请说说SpringBoot自动装配原理？

https://www.jianshu.com/p/88eafeb3f351



**5.有用过SpringCloud吗，请说说SpringCloud和Dubbo有什么不一样？**

dubbo由于是二进制的传输，占用带宽会更少

springCloud是http协议传输，带宽会比较多，同时使用http协议一般会使用JSON报文，消耗会更大

dubbo的开发难度较大，原因是dubbo的jar包依赖问题很多大型工程无法解决

springcloud的接口协议约定比较自由且松散，需要有强有力的行政措施来限制接口无序升级

dubbo的注册中心可以选择zk,redis等多种，springcloud的注册中心只能用eureka或者自研


##### 6.~~什么是WebService，如何基于WebService开发接口？~~







##### 7.请谈谈单点登录原理？



##### 8.Tomcat如何优化？



##### 9.后台系统怎么防止请求重复提交？



##### 10.Linux常见命令有哪些？



##### 11.请说说什么是Maven的依赖、继承以及聚合？

##### 12.Git暂存区和工作区的区别？

##### 13.Git如何创建、回退以及撤销版本？

##### 14.常见的设计模式有哪些



#### 分布式场景

##### 1.谈谈项目中分布式事务应用场景?

事务的ACID特性

**解决方案**

基于XA协议的两阶段提交

消息事务+最终一致性



##### 2.提交2PC、3PC与TCC

分布式事务：二阶段提交、三阶段提交、补偿事务



##### 3.CAP和BASE理论的引出

对于本地事务处理或者是集中式的事务处理系统，依照传统的ACID特性即可保证数据的严格一致性。

可是对于分布式事务，传统的单机事务模型已经无法胜任。如果我们期望实现一套严格满足ACID特性的分布式事务，很可能出现的情况就是在系统的可用性和严格一致性之间出现冲突。

因此，在可用性和一致性之间永远无法存在一个两全其美的方案，于是如何构建一个兼顾可用性和一致性的分布式系统成为了无数工程师探讨的难题，出现了诸如CAP和BASE这样的分布式系统经典理论。

**CAP定理**

CAP定理告诉我们，**分布式系统不可能同时满足一致性（C：Consistency）、可用性（A：Availability）和分区容错性（P：Partition Tolerance），最多只能同时满足其中两项。**

**一、一致性（C：Consistency）**

一致性指的是多个数据副本是否能保持一致的特性，在一致性的条件下，系统在执行数据更新操作之后能够从一致性状态转移到另一个一致性状态。

对系统的一个数据更新成功之后，如果所有用户都能够读取到最新的值，该系统就被认为具有**强一致性**。

**二、可用性（A：Availability）**

可用性指分布式系统在面对各种异常时可以提供正常服务的能力，可以用系统可用时间占总时间的比值来衡量，4 个 9 的可用性表示系统 99.99% 的时间是可用的。

在可用性条件下，要求系统提供的服务一直处于可用的状态，对于用户的每一个操作请求总是能够在有限的时间内返回结果。

**三、分区容错性（P：Partition Tolerance）**

网络分区指分布式系统中的节点被划分为多个区域，每个区域内部可以通信，但是区域之间无法通信。

在分区容错性条件下，分布式系统在遇到任何网络分区故障的时候，仍然需要能对外提供一致性和可用性的服务，除非是整个网络环境都发生了故障。

**四、权衡**

由上面我们可以看出，在分布式系统中，分区容错性必不可少，因为需要总是假设网络是不可靠的。因此，CAP 理论实际上是要在可用性和一致性之间做权衡。

可用性和一致性往往是冲突的，很难使它们同时满足。在多个节点之间进行数据同步时:

**为了保证一致性（CP），不能访问未同步完成的节点，也就失去了部分可用性；**

**为了保证可用性（AP），允许读取所有节点的数据，但是数据可能不一致。**



**BASE理论**

BASE 是**基本可用（Basically Available）、软状态（Soft State）和最终一致性（Eventually Consistent）三个短语**的缩写。

BASE 理论是对 CAP 中**一致性和可用性权衡的结果**，它的核心思想是：**即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性。**

**基本可用**

指分布式系统在出现故障的时候，保证核心可用，允许损失部分可用性。

例如，电商在做促销时，为了保证购物系统的稳定性，部分消费者可能会被引导到一个降级的页面。

**软状态**

指允许系统中的数据存在中间状态，并认为该中间状态不会影响系统整体可用性，即允许系统不同节点的数据副本之间进行同步的过程存在时延。

**最终一致性**

最终一致性强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能达到一致的状态。

**ACID 要求强一致性，通常运用在传统的数据库系统上**。而 **BASE 要求最终一致性，通过牺牲强一致性来达到可用性，通常运用在大型分布式系统中。**

在实际的分布式场景中，不同业务单元和组件对一致性的要求是不同的，因此 ACID 和 BASE 往往会结合在一起使用



##### 3.谈谈反设计模式





#### java基础以及多个"比较"

##### **1.Collections.sort排序内部原理**

在Java 6中Arrays.sort()和Collections.sort()使用的是MergeSort，而在Java 7中，内部实现换成了TimSort，其对对象间比较的实现要求更加严格

##### 2.hashMap原理，java8做的改变

从结构实现来讲，HashMap是**数组+链表+红黑树**（**JDK1.8增加了红黑树部分**）实现的。**HashMap最多只允许一条记录的键为null**，允许多条记录的值为null。HashMap非线程安全。ConcurrentHashMap线程安全。解决碰撞：**当出现冲突时，运用拉链法**，将关键词为同义词的结点链接在一个单链表中，散列表长m，则定义一个由m个头指针组成的指针数组T，地址为i的结点插入以T(i)为头指针的单链表中。Java8中，**冲突的元素超过限制（8），用红黑树替换链表**。



####Redis

##### 1.redis 是什么？都有哪些使用场景？

NoSQL(NoSQL = Not Only SQL )，意即“不仅仅是SQL”，

**Redis:REmote DIctionary Server(远程字典服务器)**
是完全开源免费的，用C语言编写的，遵守BSD协议，
是一个高性能的(key/value)分布式内存数据库，基于内存运行
并支持持久化的NoSQL数据库，是当前最热门的NoSql数据库之一,也被人们称为数据结构服务器。
优点：

**Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用。RDB和AOF**
**Redis不仅仅支持简单的key-value类型的数据，提供5种数据类型（string，list，hash，set，zset）**
Redis支持数据的备份，即master-slave模式的数据备份

**应用场景：**

1. **内存存储和持久化：redis支持异步将内存中的数据写到硬盘上，同时不影响继续服务**
2. **取最新N个数据的操作**，如：可以将最新的10条评论的ID放在Redis的List集合里面
3. 模拟类似于HttpSession这种需要设定过期时间的功能；**session集中化**
4. **发布、订阅消息系统**
5. 定时器、计数器
6. 分布式锁（setnx、watch）
7. 限时业务的运用
8. 热点数据的缓存
9. 延时操作

##### 2.redis 有哪些功能？

基于本机内存的缓存、服务端Redis、持久化、哨兵（Sentinel）和复制（Replication）、集群（Cluster）、

发布/订阅、慢查询、Lua支持

##### 3.redis 和 memecache 有什么区别？

1)、存储方式
 Memecache把数据全部存在内存之中，断电后会挂掉，数据不能超过内存大小。
 Redis有部份存在硬盘上，这样能保证数据的持久性。
 2)、数据支持类型
 Memcache对数据类型支持相对简单。
 Redis有复杂的数据类型。
 3)、使用底层模型不同
 它们之间底层实现方式 以及与客户端之间通信的应用协议不一样。
 Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。
 4），value大小
 redis最大可以达到1GB，而memcache只有1MB

##### 4.redis 为什么是单线程的？

以前一直有个误区，以为：高性能服务器  一定是 多线程来实现的 

原因很简单因为误区二导致的： 多线程 一定比 单线程  效率高。其实不然。

在说这个事前希望大家都能对  CPU 、 内存 、 硬盘的速度都有了解了，这样可能理解得更深刻一点，不了解的朋友点：[CPU到底比内存跟硬盘快多少](http://blog.csdn.net/world6/article/details/79375690)

[redis](https://cloud.tencent.com/product/crs?from=10680) 核心就是 如果我的数据全都在内存里，我单线程的去操作 就是效率最高的，为什么呢，因为多线程的本质就是 CPU 模拟出来多个线程的情况，这种模拟出来的情况就有一个代价，就是上下文的切换，对于一个内存的系统来说，它没有上下文的切换就是效率最高的。redis 用 单个CPU 绑定一块内存的数据，然后针对这块内存的数据进行多次读写的时候，都是在一个CPU上完成的，所以它是单线程处理这个事。在内存的情况下，这个方案就是最佳方案  —— 阿里 沈询 

因为一次CPU上下文的切换大概在 1500ns 左右。

从内存中读取 1MB 的连续数据，耗时大约为 250us，假设1MB的数据由多个线程读取了1000次，那么就有1000次时间上下文的切换，

那么就有1500ns * 1000 = 1500us ，我单线程的读完1MB数据才250us ,你光时间上下文的切换就用了1500us了，我还不算你每次读一点数据 的时间，

那什么时候用多线程的方案呢？

答案是：下层的存储等慢速的情况。比如磁盘

内存是一个 IOPS 非常高的系统，因为我想申请一块内存就申请一块内存，销毁一块内存我就销毁一块内存，内存的申请和销毁是很容易的。而且内存是可以动态的申请大小的。

磁盘的特性是：IPOS很低很低，但吞吐量很高。这就意味着，大量的读写操作都必须攒到一起，再提交到磁盘的时候，性能最高。为什么呢？

如果我有一个事务组的操作（就是几个已经分开了的事务请求，比如写读写读写，这么五个操作在一起），在内存中，因为IOPS非常高，我可以一个一个的完成，但是如果在磁盘中也有这种请求方式的话，

我第一个写操作是这样完成的：我先在硬盘中寻址，大概花费10ms，然后我读一个数据可能花费1ms然后我再运算（忽略不计），再写回硬盘又是10ms ，总共21ms

第二个操作去读花了10ms, 第三个又是写花费了21ms ,然后我再读10ms, 写21ms ，五个请求总共花费83ms，这还是最理想的情况下，这如果在内存中，大概1ms不到。

所以对于磁盘来说，它吞吐量这么大，那最好的方案肯定是我将N个请求一起放在一个buff里，然后一起去提交。

方法就是用异步：将请求和处理的线程不绑定，请求的线程将请求放在一个buff里，然后等buff快满了，处理的线程再去处理这个buff。然后由这个buff 统一的去写入磁盘，或者读磁盘，这样效率就是最高。 java里的 IO不就是这么干的么~

对于慢速设备，这种处理方式就是最佳的，慢速设备有磁盘，网络 ，SSD 等等，

 多线程 ，异步的方式处理这些问题非常常见，大名鼎鼎的netty 就是这么干的。

终于把 redis 为什么是单线程说清楚了，把什么时候用单线程跟多线程也说清楚了，其实也是些很简单的东西，只是基础不好的时候，就真的尴尬。。。。 

补一发大师语录：来说说，为何单核cpu绑定一块内存效率最高

“我们不能任由操作系统[负载均衡](https://cloud.tencent.com/product/clb?from=10680)，因为我们自己更了解自己的程序，所以我们可以手动地为其分配CPU核，而不会过多地占用CPU”，默认情况下单线程在进行系统调用的时候会随机使用CPU内核，为了优化Redis，我们可以使用工具为单线程绑定固定的CPU内核，减少不必要的性能损耗！

##### 5.什么是缓存穿透？怎么解决？

**一．缓存穿透：**

     缓存穿透是指查询一个一定不存在的数据，由于缓存是不命中时需要从数据库查询，查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到数据库去查询，造成缓存穿透。
    
     解决办法：
    
     1.布隆过滤

  **对所有可能查询的参数以hash形式存储，在控制层先进行校验，不符合则丢弃**。还有最常见的则是**采用布隆过滤器**，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。

  补充:

      Bloom filter

  适用范围：**可以用来实现数据字典，进行数据的判重，或者集合求交集**

  基本原理及要点：对于原理来说很简单，位数组+k个独立hash函数。将hash函数对应的值的位数组置1，查找时如果发现所有hash函数对应位都是1说明存在，很明显这个过程并不保证查找的结果是100%正确的。同时也不支持删除一个已经插入的关键字，因为该关键字对应的位会牵动到其他的关键字。所以一个简单的改进就是counting Bloom filter，用一个counter数组代替位数组，就可以支持删除了。添加时增加计数器，删除时减少计数器。

     2. 缓存空对象. 将 null 变成一个值.

  也可以采用一个更为简单粗暴的方法，如果一个查询返回的数据为空（不管是数 据不存在，还是系统故障），我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。

 缓存空对象会有两个问题：

 第一，空值做了缓存，意味着缓存层中存了更多的键，需要更多的内存空间 ( 如果是攻击，问题更严重 )，比较有效的方法是针对这类数据设置一个较短的过期时间，让其自动剔除。

 第二，缓存层和存储层的数据会有一段时间窗口的不一致，可能会对业务有一定影响。例如过期时间设置为 5分钟，如果此时存储层添加了这个数据，那此段时间就会出现缓存层和存储层数据的不一致，此时可以利用消息系统或者其他方式清除掉缓存层中的空对象。

二.缓存雪崩

    如果缓存集中在一段时间内失效，发生大量的缓存穿透，所有的查询都落在数据库上，造成了缓存雪崩。
    
    这个没有完美解决办法，但可以分析用户行为，尽量让失效时间点均匀分布。大多数系统设计者考虑用加锁或者队列的方式保证缓存的单线程（进程）写，从而避免失效时大量的并发请求落到底层存储系统上。

 解决方法

   1. **加锁排队. 限流-- 限流算法. 1.计数 2.滑动窗口 3.  令牌桶Token Bucket 4.漏桶 leaky bucket [1]**

 在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待。

 业界比较常用的做法，是使用mutex。简单地来说，就是在缓存失效的时候（判断拿出来的值为空），不是立即去load db，而是先使用缓存工具的某些带成功操作返回值的操作（比如Redis的SETNX或者Memcache的ADD）去set一个mutex key，当操作返回成功时，再进行load db的操作并回设缓存；否则，就重试整个get缓存的方法。

SETNX，是「SET if Not eXists」的缩写，也就是只有不存在的时候才设置，可以利用它来实现锁的效果。

     2.数据预热

  可以通过缓存reload机制，预先去更新缓存，再即将发生大并发访问前手动触发加载缓存不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀

  3.做二级缓存，或者双缓存策略。

     A1为原始缓存，A2为拷贝缓存，A1失效时，可以访问A2，A1缓存失效时间设置为短期，A2设置为长期。

   4.缓存永远不过期

 这里的“永远不过期”包含两层意思：

    (1) 从缓存上看，确实没有设置过期时间，这就保证了，不会出现热点key过期问题，也就是“物理”不过期。
    
     (2) 从功能上看，如果不过期，那不就成静态的了吗？所以我们把过期时间存在key对应的value里，如果发现要过期了，通过一个后台的异步线程进行缓存的构建，也就是“逻辑”过期.

 从实战看，这种方法对于性能非常友好，唯一不足的就是构建缓存时候，其余线程(非构建缓存的线程)可能访问的是老数据，但是对于一般的互联网功能来说这个还是可以忍受。


##### ~~6.redis 支持的数据类型有哪些？~~

五种

##### 7.redis 支持的 java 客户端都有哪些？

Redisson,Jedis，lettuce等等，官方推荐使用Redisson

#####8. jedis 和 redisson 有哪些区别？

Jedis 和 Redisson 都是Java中对Redis操作的封装。Jedis 只是简单的封装了 Redis 的API库，可以看作是Redis客户端，它的方法和Redis 的命令很类似。Redisson 不仅封装了 redis ，还封装了对更多数据结构的支持，以及锁等功能，相比于Jedis 更加大。但Jedis相比于Redisson 更原生一些，更灵活。



Redisson是一个在Redis的基础上实现的Java驻内存数据网格（In-Memory Data Grid）。它不仅提供了一系列的分布式的Java常用对象，还提供了许多分布式服务。其中包括Bitset, Set, MultiMap, SortedSet, Map, List, Queue, BlockingQueue, Deque, BlockingDeque, Semaphore, Lock, AtomicLong, CountDownLatch, Publish/Subscribe, Bloom filter, Remote service, Spring cache, Executor service, Live Object service, Scheduler service。Redisson提供了使用Redis的最简单和最便捷的方法。Redisson的宗旨是促进使用者对Redis的关注分离（Separation of Concern），从而让使用者能够将精力更集中地放在处理业务逻辑上



##### 9.怎么保证缓存和数据库数据的一致性？

淘汰缓存还是更新缓存？

**选择淘汰缓存**

原因：数据可能为简单数据，也可能为较复杂的数据，复杂数据进行缓存的更新操作，成本较高，因此一般推荐淘汰缓存

先淘汰缓存还是先更新数据库？

**选择先\**淘汰缓存\**，再\**更新数据库\****

原因：假如先更新数据库，再淘汰缓存，假如缓存淘汰失败，那么后面的请求都会得到脏数据，直至缓存过期。假如先淘汰缓存再更新数据库，如果数据库更新失败，只会产生一次缓存miss，相比较而言，后者对业务影响更小一点。

延时双删策略

如下场景：同时有一个请求A进行更新操作，另一个请求B进行查询操作。
（1）请求A进行写操作，删除缓存
（2）请求B查询发现缓存不存在
（3）请求B去数据库查询得到旧值
（4）请求B将旧值写入缓存
（5）请求A将新值写入数据库

次数便出现了数据不一致问题。采用延时双删策略得以解决

```c
public void write(String key,Object data){
    redisUtils.del(key);
    db.update(data);
    Thread.Sleep(100);
    redisUtils.del(key);
}
```

这么做，可以将1秒内所造成的缓存脏数据，再次删除。这个时间设定可根据俄业务场景进行一个调节。

数据库读写分离的场景

两个请求，一个请求A进行更新操作，另一个请求B进行查询操作。

（1）请求A进行写操作，删除缓存
（2）请求A将数据写入数据库了，
（3）请求B查询缓存发现，缓存没有值
（4）请求B去从库查询，这时，还没有完成主从同步，因此查询到的是旧值
（5）请求B将旧值写入缓存
（6）数据库完成主从同步，从库变为新值

依旧采用延时双删策略解决此问题



##### ~~10.redis 持久化有几种方式？~~

AOF

RDB

##### 11.redis 怎么实现分布式锁？

分布式锁常见的三种实现方式：

1. 数据库乐观锁；
2. 基于Redis的分布式锁；
3. 基于ZooKeeper的分布式锁。

本地面试考点是，你对Redis使用熟悉吗？Redis中是如何实现分布式锁的。

**要点**

Redis要实现分布式锁，以下条件应该得到满足

**互斥性**

- 在任意时刻，只有一个客户端能持有锁。

**不能死锁**

- 客户端在持有锁的期间崩溃而没有主动解锁，也能保证后续其他客户端能加锁。

**容错性**

- 只要大部分的Redis节点正常运行，客户端就可以加锁和解锁。

**实现**

可以直接通过 `set key value px milliseconds nx` 命令实现加锁， 通过Lua脚本实现解锁。



**watch**

**setnx**



##### 12.redis 分布式锁有什么缺陷？

**Redis 分布式锁不能解决超时的问题，分布式锁有一个超时时间，程序的执行如果超出了锁的超时时间就会出现问题。**



##### 13.redis 如何做内存优化？

1、缩减键值对象

　　缩减键（key）和值（value）的长度，

- key长度：如在设计键时，在完整描述业务情况下，键值越短越好。
- value长度：值对象缩减比较复杂，常见需求是把业务对象序列化成二进制数组放入Redis。首先应该在业务上精简业务对象，去掉不必要的属性避免存储无效数据。其次在序列化工具选择上，应该选择更高效的序列化工具来降低字节数组大小。以JAVA为例，内置的序列化方式无论从速度还是压缩比都不尽如人意，这时可以选择更高效的序列化工具，如: protostuff，kryo等，下图是JAVA常见序列化工具空间压缩对比。

2、共享对象池

　　对象共享池指Redis内部维护[0-9999]的整数对象池。创建大量的整数类型redisObject存在内存开销，每个redisObject内部结构至少占16字节，甚至超过了整数自身空间消耗。所以Redis内存维护一个[0-9999]的整数对象池，用于节约内存。 除了整数值对象，其他类型如list,hash,set,zset内部元素也可以使用整数对象池。因此开发中在满足需求的前提下，尽量使用整数对象以节省内存。

3、字符串优化

4、编码优化

5、控制key的数量

##### 14.redis 淘汰策略有哪些？

1）voltile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰
2）volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰
3）volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰
4）allkeys-lru：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰
5）allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰
6）no-enviction（驱逐）：禁止驱逐数据

##### redis 常见的性能问题有哪些？该如何解决？

