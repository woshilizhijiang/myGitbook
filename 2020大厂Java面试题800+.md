### Java 面试题（一）

1、面向对象的特征有哪些方面？

- 抽象：数据抽象、行为抽象
- 继承：从已有类得到继承信息。（父类、子类）
- 封装：封装复杂实现，提供简单编程接口
- 多态性：允许不同子类型的对象对同一消息作出不同的响应。编译时及运行时多态性。

2、访问修饰符 public,private,protected,以及不写（默认）时的区别？

| 属性关键字 | 当前类 | 同包 | 子类 | 其他包 |
| ---------- | ------ | ---- | ---- | ------ |
| public     | ✔      | ✔    | ✔    | ✔      |
| protected  | ✔      | ✔    | ✔    | ×      |
| default    | ✔      | ✔    | ×    | ×      |
| private    | ✔      | ×    | ×    | ×      |

3、String 是最基本的数据类型吗？

基础类型（primitive type）只有8种，剩下都是引用类型（referencetype）；java5引入枚举类型也算比较特殊的引用类型。
考点：基础类型和引用类型

4、float f=3.4;是否正确？

不对，3.4为double

5、short s1 = 1; s1 = s1 + 1;有错吗?short s1 = 1; s1 += 1;有错吗？

类型转换
short s1 = 1; s1 = s1 + 1 错误
short s1 = 1; s1 += 1  正确   **暗含（ s1 = short(s1+1)）**

6、Java 有没有 goto？
没有：但是时java保留字

**7、int 和 Integer 有什么区别？**

```java
//AutoBoxing
//实际相当于：
//Integer total = Integer.valueOf(99)
Integer total = 99;


//UnBoxing
//实际相当于：
//int totalprim = total.intValue()
int i = total;

/**************************************Integer源码分析***************************************************/
包装类
-127～128
IntegerCache
```

8、&和&&的区别？
短路



**9、解释内存中的栈(stack)、堆(heap)和方法区(method area)的用法。**



10、Math.round(11.5) 等于多少？Math.round(-11.5)等于多少？
12  -11



**11、switch 是否能作用在 byte 上，是否能作用在 long 上，是否能作用在 String 上？**

jdk1.5前:char  byte  int  short 
jdk1.5:枚举

jdk1.7:字符串（String）

long暂不支持

12、用最有效率的方法计算 2 乘以 8？
考偏移量
n * 31 == n<<5 -n

**13、数组有没有 length()方法？String 有没有 length()方法？**

数组没有 length()方法 ，有 length 的属性。String 有 length()方法。JavaScript中，获得字符串的长度是通过 length 属性得到的，这一点容易和 Java 混淆。

14、在 Java 中，如何跳出当前的多重嵌套循环？



15、构造器（constructor）是否可被重写（override）？

Java 重写(Override)与重载(Overload)区别

重写：

1. **子类覆写父类方法**
2. **运行时加载**

**重载：**

1. **方法名相同，参数个数不同**
2. **编译时加载**



~~16、两个对象值相同(x.equals(y) == true)，但却可有不同的 hashcode，这句话对不对？~~



17~~、是否可以继承 String 类？~~



18、当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递？

java值传递


19、String 和 StringBuilder、StringBuffer 的区别？
final 不可被修改
StringBuilder 可修改、线程不安全
StringBuffer 可修改过、线程安全



20、重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？

override：子类重写父类

overload：方法相同、参数不同；重载与参数类型无关



***21、描述一下 JVM 加载 class 文件的原理机制？***

22、char 型变量中能不能存贮一个中文汉字，为什么？

23、抽象类（abstract class）和接口（interface）有什么异同？

24、静态嵌套类(Static Nested Class)和内部类（Inner Class）的不同？

25、Java 中会存在内存泄漏吗，请简单描述。

26、抽象的（abstract）方法是否可同时是静态的（static）,是否可同时是本地方法（native），是否可同时被 synchronized 修饰？

27、阐述静态变量和实例变量的区别。

28、是否可以从一个静态（static）方法内部发出对非静态（non-static）方法的调用？

29、如何实现对象克隆？

30、GC 是什么？为什么要有 GC？

31、String s = new String(“xyz”);创建了几个字符串对象？

32 、 接 口 是 否 可 继 承 （ extends ） 接 口 ？ 抽 象 类 是 否 可 实 现（implements）接口？抽象类是否可继承具体类（concrete class）？

33、一个”.java”源文件中是否可以包含多个类（不是内部类）？有什么限制？

34、Anonymous Inner Class(匿名内部类)是否可以继承其它类？是否可以实现接口？

35、内部类可以引用它的包含类（外部类）的成员吗？有没有什么限制？

36、Java 中的 final 关键字有哪些用法？

37、指出下面程序的运行结果

38、数据类型之间的转换：

39、如何实现字符串的反转及替换？

40、怎样将 GB2312 编码的字符串转换为 ISO-8859-1 编码的字符串？

41、日期和时间：

42、打印昨天的当前时刻。

43、比较一下 Java 和 JavaSciprt。

44、什么时候用断言（assert）？

45、Error 和 Exception 有什么区别？

46、try{}里有一个 return 语句，那么紧跟在这个 try 后的 finally{}里的代码会不会被执行，什么时候被执行，在 return 前还是后?

47、Java 语言如何进行异常处理，关键字：throws、throw、try、catch、finally 分别如何使用？

48、运行时异常与受检异常有何异同？

49、列出一些你常见的运行时异常？

50、阐述 final、finally、finalize 的区别。

51、类 ExampleA 继承 Exception，类 ExampleB 继承 ExampleA。

52、List、Set、Map 是否继承自 Collection 接口？

53、阐述 ArrayList、Vector、LinkedList 的存储性能和特性。

54、Collection 和 Collections 的区别？

55、List、Map、Set 三个接口存取元素时，各有什么特点？

56、TreeMap 和 TreeSet 在排序时如何比较元素？Collections 工具类中的 sort()方法如何比较元素？

57、Thread 类的 sleep()方法和对象的 wait()方法都可以让线程暂停执行，它们有什么区别?

58、线程的 sleep()方法和 yield()方法有什么区别？

59、当一个线程进入一个对象的 synchronized 方法 A 之后，其它线程是否可进入此对象 synchronized 方法 B？

60、请说出与线程同步以及线程调度相关的方法。

61、编写多线程程序有几种实现方式？

62、synchronized 关键字的用法？

63、举例说明同步和异步。

64、启动一个线程是调用 run()还是 start()方法？

65、什么是线程池（thread pool）？

66、线程的基本状态以及状态之间的关系？

67、简述 synchronized 和 java.util.concurrent.locks.Lock 的异同？

68、Java 中如何实现序列化，有什么意义？

69、Java 中有几种类型的流？

70、写一个方法，输入一个文件名和一个字符串，统计这个字符串在这个文件中出现的次数。

71、如何用 Java 代码列出一个目录下所有的文件？

72、用 Java 的套接字编程实现一个多线程的回显（echo）服务器。

73、XML 文档定义有几种形式？它们之间有何本质区别？解析 XML文档有哪几种方式？

74、你在项目中哪些地方用到了 XML？



**75、阐述 JDBC 操作数据库的步骤。**

非池化

1.加载驱动

```java
Class.forName("oracle.jdbc.driver.OracleDriver");
```

2.创建连接

```java
Connection con = DriverManager.getConnection("jdbc:oracle:thin:@localhost:1521:orcl","lizhijiang", "1qaz!QAZ");
```

3.创建语句

```java
PrepareStatement ps = con.prepareStatement("select * from temp where sal between ? and ?");
ps.setint(1, 1000);
ps.setint(2, 3000);
```

4.执行语句

```java
ResultSet = ps.executeQuery();
```

5.处理结果

```java
while(rs.next()){
  System.out.println(rs.getint("empno") + " - " + rs.getString("ename"));
}
```

6.关闭资源

```java
finally {
    if(con != null) {
        try {
            con.close();
        }
        catch (SQLException e) {
            e.printStackTrace();
        }
    }
}
```



76、Statement 和 PreparedStatement 有什么区别？哪个性能更好？

**PreparedStatement:预编译、防止SQL注入、参数赋值和定义分离**
**高并发时PreparedStatement预编译 性能更佳**

**77、使用 JDBC 操作数据库时，如何提升读取数据的性能？如何提升更新数据的性能？**
**接口 java.sql.ResultSet的void setFetchSize（int rows） 指定每次抓取记录数据（典型的空间换时间策略）；**

**要提升更新数据的性能可以使用 PreparedStatement 语句构建批处理，将若干 SQL 语句置于一个批处理中执行**



78、在进行数据库编程时，连接池有什么作用？

基于 Java 的开源数据库连接池主要有：C3P0、Proxool、DBCP、BoneCP、Druid 等。


**79、什么是 DAO 模式？**
**Data Access Object**



**80、事务的 ACID 是指什么？**



**81、JDBC 中如何进行事务处理？**

**java.sql.Connection 的setAutoCommit(false)  、rollback()**

**JDBC 3.0 中还引入了Savepoint（保存点）的概念，允许通过代码设置保存点并让事务回滚到指定的保存点。**

**82、JDBC 能否处理 Blob 和 Clob？**

Blob 是指二进制大对象（Binary Large Object），而 Clob 是指大字符对象（Character Large Objec）



83、简述正则表达式及其用途。

84、Java 中是如何支持正则表达式操作的？

**85、获得一个类的类对象有哪些方式？**

**（1）方法 1：类型.class，例如：String.class**

**（2）方法 2：对象.getClass()，例如：”hello”.getClass()**

**（3）方法 3：Class.forName()，例如：Class.forName(“java.lang.String”)**

**88、如何通过反射调用对象的方法？**

**方法 1：通过类对象调用 newInstance()方法，例如：String.class.newInstance()**

**方法 2：通过类对象的 getConstructor()或 getDeclaredConstructor()方法获得构造器（Constructor）对象并调用其 newInstance()方法创建对象，例如：String.class.getConstructor(String.class).newInstance(“Hello”);**



89、简述一下面向对象的”六原则一法则”

90、简述一下你了解的设计模式。



91、用 Java 写一个单例类。

92、什么是 UML？

93、UML 中有哪些常用的图？

**94、用 Java 写一个冒泡排序。**



**95、用 Java 写一个折半查找。**





### Java 面试题（二）

1、Java 中能创建 volatile 数组吗？



2、volatile 能使得一个非原子操作变成原子操作吗？



3、volatile 修饰符的有过什么实践？



4、volatile 类型变量提供什么保证？

5、10 个线程和 2 个线程的同步代码，哪个更容易写？

6、你是如何调用 wait（）方法的？使用 if 块还是循环？为什么？

8、什么是 Busy spin？我们为什么要使用它？

9、Java 中怎么获取一份线程 dump 文件？

10、Swing 是线程安全的？

11、什么是线程局部变量？

12、用 wait-notify 写一段代码来解决生产者-消费者问题？

13、用 Java 写一个线程安全的单例模式（Singleton）？

14、Java 中 sleep 方法和 wait 方法的区别？

15、什么是不可变对象（immutable object）？Java 中怎么创建一个不可变对象？

16、我们能创建一个包含可变对象的不可变对象吗？

17、Java 中应该使用什么数据类型来代表价格？

18、怎么将 byte 转换为 String？

19、Java 中怎样将 bytes 转换为 long 类型？

20、我们能将 int 强制转换为 byte 类型的变量吗？如果该值大于byte 类型的范围，将会出现什么现象？

21、存在两个类，B 继承 A ，C 继承 B，我们能将 B 转换为 C 么？如 C = (C) B；

22、哪个类包含 clone 方法？是 Cloneable 还是 Object？

23、Java 中 ++ 操作符是线程安全的吗？

23、不是线程安全的操作。它涉及到多个指令，如读取变量值，增加，然后存储回内存，这个过程可能会出现多个线程交差。

24、a = a + b 与 a += b 的区别

25、我能在不进行强制转换的情况下将一个 double 值赋值给 long类型的变量吗？

26、3*0.1 == 0.3 将会返回什么？true 还是 false？

27、int 和 Integer 哪个会占用更多的内存？

28、为什么 Java 中的 String 是不可变的（Immutable）？

31、64 位 JVM 中，int 的长度是多数？

32、Serial 与 Parallel GC 之间的不同之处？

33、32 位和 64 位的 JVM，int 类型变量的长度是多数？

34、Java 中 WeakReference 与 SoftReference 的区别？

35、WeakHashMap 是怎么工作的？

36、JVM 选项 -XX:+UseCompressedOops 有什么作用？为什么要使用？

37、怎样通过 Java 程序来判断 JVM 是 32 位 还是 64 位？

38、32 位 JVM 和 64 位 JVM 的最大堆内存分别是多数？

39、JRE、JDK、JVM 及 JIT 之间有什么不同？

40、解释 Java 堆空间及 GC？

41、你能保证 GC 执行吗？

42、怎么获取 Java 程序使用的内存？堆使用的百分比？

43、Java 中堆和栈有什么区别？

44、“a==b”和”a.equals(b)”有什么区别？

45、a.hashCode() 有什么用？与 a.equals(b) 有什么关系？

46、final、finalize 和 finally 的不同之处？

47、Java 中的编译期常量是什么？使用它又什么风险？

48、List、Set、Map 和 Queue 之间的区别(答案)

49、poll() 方法和 remove() 方法的区别？

50、Java 中 LinkedHashMap 和 PriorityQueue 的区别是什么？

51、ArrayList 与 LinkedList 的不区别？

52、用哪两种方式来实现集合的排序？

53、Java 中怎么打印数组？

54、Java 中的 LinkedList 是单向链表还是双向链表？

55、Java 中的 TreeMap 是采用什么树实现的？(答案)

56、Hashtable 与 HashMap 有什么不同之处？

57、Java 中的 HashSet，内部是如何工作的？

58、写一段代码在遍历 ArrayList 时移除一个元素？

59、我们能自己写一个容器类，然后使用 for-each 循环码？

60、ArrayList 和 HashMap 的默认大小是多数？

61、有没有可能两个不相等的对象有有相同的 hashcode？

62、两个相同的对象会有不同的的 hash code 吗？

63、我们可以在 hashcode() 中使用随机数字吗？

64、Java 中，Comparator 与 Comparable 有什么不同？

66、在我 Java 程序中，我有三个 socket，我需要多少个线程来处理？

67、Java 中怎么创建 ByteBuffer？

68、Java 中，怎么读写 ByteBuffer ？

69、Java 采用的是大端还是小端？

70、ByteBuffer 中的字节序是什么？

71、Java 中，直接缓冲区与非直接缓冲器有什么区别？

72、Java 中的内存映射缓存区是什么？

73、socket 选项 TCP NO DELAY 是指什么？

74、TCP 协议与 UDP 协议有什么区别？

75、Java 中，ByteBuffer 与 StringBuffer 有什么区别？(答案)

76、Java 中，编写多线程程序的时候你会遵循哪些最佳实践？

77、说出几点 Java 中使用 Collections 的最佳实践

78、说出至少 5 点在 Java 中使用线程的最佳实践。

79、说出 5 条 IO 的最佳实践(答案)

80、列出 5 个应该遵循的 JDBC 最佳实践

81、说出几条 Java 中方法重载的最佳实践？

82、在多线程环境下，SimpleDateFormat 是线程安全的吗？

83、Java 中如何格式化一个日期？如格式化为 ddMMyyyy 的形式？

84、Java 中，怎么在格式化的日期中显示时区？

85、Java 中 java.util.Date 与 java.sql.Date 有什么区别？

86、Java 中，如何计算两个日期之间的差距？

87、Java 中，如何将字符串 YYYYMMDD 转换为日期？

89、如何测试静态方法？(答案)

90、怎么利用 JUnit 来测试一个方法的异常？

91、你使用过哪个单元测试库来测试你的 Java 程序？

92、@Before 和 @BeforeClass 有什么区别？

93、怎么检查一个字符串只包含数字？解决方案

94、Java 中如何利用泛型写一个 LRU 缓存？

95、写一段 Java 程序将 byte 转换为 long？

96、在不使用 StringBuffer 的前提下，怎么反转一个字符串？

97、Java 中，怎么获取一个文件中单词出现的最高频率？

98、如何检查出两个给定的字符串是反序的？

99、Java 中，怎么打印出一个字符串的所有排列？

100、Java 中，怎样才能打印出数组中的重复元素？

101、Java 中如何将字符串转换为整数？

102、在没有使用临时变量的情况如何交换两个整数变量的值？

103、接口是什么？为什么要使用接口而不是直接使用具体类？

104、Java 中，抽象类与接口之间有什么不同？

105、除了单例模式，你在生产环境中还用过什么设计模式？

106、你能解释一下里氏替换原则吗?

107、什么情况下会违反迪米特法则？为什么会有这个问题？

108、适配器模式是什么？什么时候使用？

109、什么是“依赖注入”和“控制反转”？为什么有人使用？

110、抽象类是什么？它与接口有什么区别？你为什么要使用过抽象类？

111、构造器注入和 setter 依赖注入，那种方式更好？

112、依赖注入和工程模式之间有什么不同？

113、适配器模式和装饰器模式有什么区别？

114、适配器模式和代理模式之前有什么不同？

115、什么是模板方法模式？

116、什么时候使用访问者模式？

117、什么时候使用组合模式？

118、继承和组合之间有什么不同？

119、描述 Java 中的重载和重写？

120、Java 中，嵌套公共静态类与顶级类有什么不同？

121、 OOP 中的 组合、聚合和关联有什么区别？

122、给我一个符合开闭原则的设计模式的例子？

123、抽象工厂模式和原型模式之间的区别？

125、嵌套静态类与顶级类有什么区别？

126、你能写出一个正则表达式来判断一个字符串是否是一个数字吗？

127、Java 中，受检查异常 和 不受检查异常的区别？

128、Java 中，throw 和 throws 有什么区别

129、Java 中，Serializable 与 Externalizable 的区别？

130、Java 中，DOM 和 SAX 解析器有什么不同？

131、说出 JDK 1.7 中的三个新特性？

132、说出 5 个 JDK 1.8 引入的新特性？

133、Java 中，Maven 和 ANT 有什么区别？



### Java面试（三）



#### DDD分层架构的三种模式

DDD:Domain Driven Design==领域驱动设计

UL和BC：通用语言和限界上下文

##### 四层架构

User Interface

Application

Domain

infrastructure

**五层架构**





### Java面试（四-----BAT 大厂Java 面试题集锦之核心篇附参考答案）

#### java基础

##### 1.什么是字符串常量池？

Java设计者**为String提供了字符串常量池以提高其性能**，那么字符串常量池的具体原理是什么，带着以下三个问题，去理解字符串常量池：

1. 字符串常量池的设计意图是什么？

    **提速；缓存空间换时间；以不可变（final）类为基础，解决数据共享冲突；保持可达性，阻止程序GC回收**

2. 字符串常量池在哪里？

    **jvm方法区**

3. 如何操作字符串常量池？ 

    **String.intern()**

   

##### **2.String为什么是不可变的？**



**什么是不可变对象？**

如果一个对象，在它创建完成之后，不能再改变它的状态，那么这个对象就是不可变的。不能改变状态的意思是，不能改变对象内的成员变量，包括基本数

**String对象是不可变的呢？**

final类

**String源码构成**

```java
public final class String
implements java.io.Serializable, Comparable<String>, CharSequence {
    /** The value is used for character storage. */
    private final char value[];

    /** Cache the hash code for the string */
  private int hash; // 
```

**不可变有什么好处？**

1、多线程下安全性

2、类加载中体现的安全性

3、使用常量池可以节省空间



##### **3.String s = new String("xyz");究竟产生了几个对象，从JVM角度谈谈？**

**2个对象**

String str1 = new String("A"+"B") ; 会创建多少个对象?  **2个对象，编译优化"A"+B" 为"AB"**
String str2 = new String("ABC") + "ABC" ; 会创建多少个对象? **3个对象**



##### **4.String拼接字符串效率低，你知道原因吗？** 

ASM指令集角度分析

##### **5.你真的了解String的常见API吗？**

抓住String是final类；对旧string的操作获得的新string 皆为新对象。

```java
String是我们开发中使用频率最高的类，它有哪些方法，大家一定不会陌生，例如：

length();//计算字符串的长度

charAt();//截取一个字符

getChars();//截取多个字符

equals();//比较两个字符串

equalsIgnoreCase();//比较两个字符串,忽略大小写

startsWith();//startsWith()方法决定是否以特定字符串开始

endWith();//方法决定是否以特定字符串结束

indexOf();//查找字符或者子串第一次出现的地方。

lastIndexOf();//查找字符或者子串是后一次出现的地方。

substring();//截取字符串

concat();//连接两个字符串

replace();//替换

trim();//去掉起始和结尾的空格

valueOf();//转换为字符串

toLowerCase();//转换为小写

toUpperCase();// 转换为大写
```



##### **6.Java中的subString()真的会引起内存泄露么？**

jdk1.6出现
以后版本不存在OOM



##### **7.浅析Java中的final关键字？**

- **修饰类**，修饰的类无法被继承，例如String类、Math类、Integer类等；
- **修饰方法**，修饰的方法无法被重写；
- **修饰变量**，包括成员变量和局部变量，该变量只能被赋值一次且它的值无法被改变，对于成员变量来讲，我们必须在声明时或者构造方法中对它赋值；



##### **8.浅析Java中的static关键字？**

- static 关键字可以用来修饰：**属性、方法、内部类、代码块**；
- static 修饰的资源属于**类级别**，是全体对象实例共享的资源；
- 使用 static 修饰的属性，静态属性是在类的加载期间初始化的，使用**类名.属性**访问



##### 9.浅析Java中的volatile关键字

- volatile能保证内存可见性
- volatile不能保证原子性
- volatile禁止指令重排序

总结：volatile只能保证变量内存可见性，不能保证原子性。volatile解决的是变量在多个线程之间的可见性，而sychronized、Lock解决的是多个线程之间访问资源的同步性。



##### 10.i++是线程安全的吗?   从字节码角度深度解析 i++ 和 ++i 线程安全性原理？

i++不是线程安全的，解决办法使用synchronized关键字或者AtomicXX系列的包装类，或者JDK1.5以后提供的Lock锁;JDK1.8后特定环境LongAdder累加器。

如代码所示：

```java
 @Test
    public void test1(){
        int i = 0;
        int j;
        j = i++;
        //    LINENUMBER 14 L1
        //    ILOAD 1  //将指定的 int 型局部变量推送至栈顶
        //    IINC 1 1 //IINC M N（M 为非负整数，N 为整数）将局部变量数组的第 M 个单元中的 int 值增加 N，常用于 for 循环中自增量的更新
        //    ISTORE 2
        System.out.println(j);
    }

    /**
     * ++i
     */
    @Test
    public void test2(){
        int i = 0;
        int j;
        //    LINENUMBER 33 L1
        //    IINC 1 1  //IINC M N（M 为非负整数，N 为整数）将局部变量数组的第 M 个单元中的 int 值增加 N，常用于 for 循环中自增量的更新
        //    ILOAD 1   //将指定的 int 型局部变量推送至栈顶
        //    ISTORE 2  //将栈顶 int 型数值存入指定局部变量
        j = ++i;
        System.out.println(j);
    }
```

总结：

i++和++i字节码层面不同只是iload和iinc顺序相反，性能一样；线程不安全

```
//    ILOAD 1 //将指定的 int 型局部变量推送至栈顶
//    IINC 1 1 //IINC M N（M 为非负整数，N 为整数）将局部变量数组的第 M 个单元中的 int 值增加 N，常用于 for 循环中自增量的更新
```



##### 11.请谈谈什么是CAS？

CAS(Compare And Set)算法是硬件对于并发操作的支持，是一种**无锁的非阻塞算法**的实现。**CAS算法保证同时访问时只有一个线程**能进来，当多个线程同时并发访问操作共享数据的时候，有且只有一个能够成功，其他的线程都会失败。CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。

当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。**类似于乐观锁**。

**如失败，会自旋；多用于并发不是特别高的场景。**



##### 12.从源码角度彻底搞懂ArrayList 和LinkedList

**ArrayList**

1. 快速随机访问

2. 允许存放多个null元素

3. 底层是Object数组

4. 增加元素个数可能很慢(可能需要扩容),删除元素可能很慢(可能需要移动很多元素),改对应索引元素比较快

   

   **底层是Object数组存储数据**
   **扩容机制:默认大小是10,扩容是扩容到之前的1.5倍的大小,每次扩容都是将原数组的数据复制进新数组中**. 

   我的领悟:如果是已经知道了需要创建多少个元素,那么尽量用new ArrayList<>(13)这种明确容量的方式创建ArrayList.避免不必要的浪费.
   **添加:**如果是添加到数组的指定位置,那么可能会挪动大量的数组元素,并且可能会触发扩容机制;如果是添加到末尾的话,那么只可能触发扩容机制.
   **删除:**如果是删除数组指定位置的元素,那么可能会挪动大量的数组元素;如果是删除末尾元素的话,那么代价是最小的. ArrayList里面的删除元素,其实是将该元素置为null.
   查询和改某个位置的元素是非常快的( O(1) ).

```java
 private void grow(int minCapacity) {
        // overflow-conscious code
        int oldCapacity = elementData.length;
        int newCapacity = oldCapacity + (oldCapacity >> 1);  //1.5倍扩容
        if (newCapacity - minCapacity < 0)
            newCapacity = minCapacity;
        if (newCapacity - MAX_ARRAY_SIZE > 0)
            newCapacity = hugeCapacity(minCapacity);
        // minCapacity is usually close to size, so this is a win:
        elementData = Arrays.copyOf(elementData, newCapacity);
    }
```



**LinkedList**

- LinkedList底层是链表结构

- 插入和删除比较快（O(1)），查询则相对慢一些（O(n)）

- 因为是链表结构，所以分配的空间不要求是连续的

  **底层是双向链表存储数据,并且记录了头节点和尾节点**
  添加元素非常快,如果是添加到头部和尾部的话更快,因为已经记录了头节点和尾节点,只需要链接一下就行了. 如果是添加到链表的中间部分的话,那么多一步操作,需要先找到添加索引处的元素(因为需要链接到这里),才能进行添加.

  遍历的时候,建议采用forEach()进行遍历,这样可以在每次获取下一个元素时都非常轻松(next = next.next;). 然后如果是通过fori和get(i)的方式进行遍历的话,效率是极低的,每次get(i)都需要从最前面(或者最后面)开始往后查找i索引处的元素,效率很低.
  删除也是非常快,只需要改动一下指针就行了,代价很小.



##### **13.java中方法的参数传递机制**

**问：当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递? 
**　　答:是值传递。**Java 编程语言只有值传递参数**。当一个**对象实例**作为一个参数被传递到方法中时，**参数的值就是该对象的引用一个副本**。指向同一个对象,对象的内容可以在被调用的方法中改变，但对象的引用(不是引用的副本)是永远不会改变的。

　　**Java参数，不管是原始类型还是引用类型，传递的都是副本**(有另外一种说法是**传值**，但是说传副本更好理解吧，传值通常是相对传址而言)。

　　**如果参数类型是原始类型，那么传过来的就是这个参数的一个副本，也就是这个原始参数的值，这个跟之前所谈的传值是一样的。如果在函数中改变了副本的值不会改变原始的值.**

　　**如果参数类型是引用类型，那么传过来的就是这个引用参数的副本，这个副本存放的是参数的地址**。如果在函数中没有改变这个副本的地址，而是改变了地址中的值，那么在函数内的改变会影响到传入的参数。如果在函数中改变了副本的地址，如new一个，那么副本就指向了一个新的地址，此时传入的参数还是指向原来的 地址，所以不会改变参数的值。



##### **14.java中throw和throws的区别？**

**throw语句用在方法体内，表示抛出异常，由方法体内的语句处理。**
**throws语句用在方法声明后面，表示抛出异常，由该方法的调用者来处理。**

throws主要是声明这个方法会抛出这种类型的异常，使它的调用者知道要捕获这个异常。
throw是当程序出现某种逻辑错误时由程序员主动抛出某种特定类型的异常是，具体向外抛异常的动作，所以它是抛出一个异常实例。

throw与throws的比较
1、throws出现在方法函数头；而throw出现在函数体。
2、throws表示出现异常的一种可能性，并不一定会发生这些异常；throw则是抛出了异常，执行throw则一定抛出了某种异常对象。
3、两者都是消极处理异常的方式（这里的消极并不是说这种方式不好），只是抛出或者可能抛出异常，但是不会由函数去处理异常，真正的处理异常由函数的上层调用处理。

##### 15.finally语句块你踩过哪些坑？



##### 16.为什么重写equals方法需同时重写hashCode方法

重写equals()方法同时重写hashcode()方法，就是为了保证当两个对象通过equals()方法比较相等时，那么他们的hashCode值也一定要保证相等。



##### 17.equals() 与 == 的区别？

功能不同

"=="是判断两个变量或实例是不是指向同一个内存空间。

"equals"是判断两个变量或实例所指向的内存空间的值是不是相同。

定义不同

"equals"在JAVA中是一个方法。

"=="在JAVA中只是一个运算符合。



##### 18.StringBuffer和StringBuilder的区别，从源码角度分析?

- StringBuffer和StringBuilder都继承自抽象类AbstractStringBuilder。
- 存储数据的字符数组也没有被final修饰，说明值可以改变，且构造出来的字符串还有空余位置拼接字符串，但是拼接下去肯定也有不够用的时候，这时候它们内部都提供了一个**自动扩容机制，当发现长度不够的时候(默认长度是16)**，会自动进行扩容工作，**扩展为原数组长度的2倍加2**，创建一个新的数组，并将数组的数据复制到新数组，所以对于拼接字符串效率要比String要高。自动扩容机制是在抽象类中实现的。
- 线程安全性：StringBuffer效率低，线程安全，因为StringBuffer中很多方法都被 synchronized 修饰了，多线程访问时，线程安全，但是效率低下，因为它有加锁和释放锁的过程。StringBuilder效率高，但是线程是不安全的。

```java
 java.lang.AbstractStringBuilder
 //扩容机制
 private int newCapacity(int minCapacity) {
        // overflow-conscious code
        int newCapacity = (value.length << 1) + 2; //扩容机制 2倍+2
        if (newCapacity - minCapacity < 0) {
            newCapacity = minCapacity;
        }
        return (newCapacity <= 0 || MAX_ARRAY_SIZE - newCapacity < 0)
            ? hugeCapacity(minCapacity)
            : newCapacity;
    }
```



##### 19.HashMap的数据结构吗?为何HashMap的数组长度一定是2的次幂？

**JDK1.6,1.7 数组 + 链表**

**JDK1.8：HashMap处理“碰撞”增加了红黑树这种数据结构，当碰撞结点较少时，采用链表存储，当较大时（>8个），采用红黑树（特点是查询时间是O（logn））存储（有一个阀值控制，大于阀值(8个)，将链表存储转换成红黑树存储**



要保证初始化时 HashMap 的容量总是 2 的 n 次方，即底层数组的长度总是为 2 的 n 次方。



带来的问题就是你的HashMap 数组的利用率太低，并且链表可能因为上边的(n - 1) & hash 运算结果碰撞率过高，导致链表太深。(当然jdk 1.8已经在链表数据超过8个以后转换成了红黑树的操作，但那样也很容易造成它们之间的转换时机的提前到来)，所以说HashMap的长度一定是2的次幂，否则会出现性能问题。

##### 20.HashMap何时扩容以及它的扩容机制？

- 在对HashMap进行扩容的时候，HashMap的容量会变为原来的两倍； 
- 扩容是一个特别耗性能的操作，所以在使用HashMap的时候，如果能估算出map的大小，初始化的时候给一个大致的数值，避免map进行频繁的扩容;



##### 21.HashMap的key一般用字符串,能用其他对象吗？

HashMap中的key可以是null，基本数据类型或引用数据类型。为了HashMap的正常使用，key一般是不可变对象，至少该对象中用于计算hash值的属性要不可变，方可保证HashMap的正常使用。



##### 22.HashMap的key和value都能为null么?如果key能为null,那么它是怎么样查找值的？

**HashMap对象的key、value值均可为null。**

hashMap是根据key的hashCode来寻找存放位置的，那当key为null时， 怎么存储呢？

在put方法里头，其实第一行就处理了key=null的情况。 


HashTable key不能为空（有判空）

```java
HashTable
public synchronized V put(K key, V value) {
        // Make sure the value is not null
        if (value == null) {
            throw new NullPointerException();
        }

        // Makes sure the key is not already in the hashtable.
        Entry<?,?> tab[] = table;
        int hash = key.hashCode();
        int index = (hash & 0x7FFFFFFF) % tab.length;
        @SuppressWarnings("unchecked")
        Entry<K,V> entry = (Entry<K,V>)tab[index];
        for(; entry != null ; entry = entry.next) {
            if ((entry.hash == hash) && entry.key.equals(key)) {
                V old = entry.value;
                entry.value = value;
                return old;
            }
        }

        addEntry(hash, key, value, index);
        return null;
    }
```



##### 23. Java面试题 从源码角度分析HashSet实现原理？

HashSet实现自set接口，set集合中元素无序且不能重复；

**因为HashSet底层是基于HashMap实现的**，当你new一个HashSet时候，实际上是new了一个map，执行add方法时，实际上调用map的put方法，**value始终是PRESENT**，所以根据HashMap的一个特性: 将一个key-value对放入HashMap中时，首先根据key的hashCode()返回值决定该Entry的存储位置，如果两个key的hash值相同，那么它们的存储位置相同。如果这个两个key的equalus比较返回true。那么新添加的Entry的value会覆盖原来的Entry的value，key不会覆盖。因此,如果向HashSet中添加一个已经存在的元素，新添加的集合元素不会覆盖原来已有的集合元素；



##### **24.HashTable与HashMap的实现原理有什么不同？**

**1.Null Key & Null Value**
HashMap是支持null键和null值的，允许一个null键和多个null值，而HashTable不允许null键值，在遇到null时，会抛出NullPointerException异常。HashMap在实现时对null做了特殊处理，将null的hashCode值定为了0，从而将其存放在哈希表的第0个bucket中。2.实现原理

**2.1数据结构**

HashMap和HashTable都使用哈希表来存储键值对。在数据结构上是基本相同的，都创建了一个继承自Map.Entry的私有的内部类Entry，每一个Entry对象表示存储在哈希表中的一个键值对。

**2.2算法**

HashMap的相关参数

默认的数组初始容量：16

**哈希碰撞**
当两个key通过hashCode计算相同时，则发生了hash冲突(碰撞)，HashMap解决hash冲突的方式是用链表。

当发生hash冲突时，则将存放在数组中的Entry设置为新值的next（这里要注意的是，比如A和B都hash后都映射到下标i中，之前已经有A了，当map.put(B)时，将B放到下标i中，A则为B的next，所以新值存放在数组中，旧值在新值的链表上）


##### 25.什么是自动拆装箱？





##### 26.String.valueOf和Integer.toString的区别？

 **Integer.toString()方法**

该方法返回指定整数的有符号位的String对象，以10进制字符串形式返回。

String.valueof()方法

不同于Integer.toString(int)，valueof有大量的重载方法，我们一一对其介绍。



#### java多线程

##### 1.线程的生命周期包括哪几个阶段？

6个阶段；根据java.lang.Thread.State

```java
 public enum State {
        /**
         * Thread state for a thread which has not yet started.
         */
        NEW,

        /**
         * Thread state for a runnable thread.  A thread in the runnable
         * state is executing in the Java virtual machine but it may
         * be waiting for other resources from the operating system
         * such as processor.
         */
        RUNNABLE,

        /**
         * Thread state for a thread blocked waiting for a monitor lock.
         * A thread in the blocked state is waiting for a monitor lock
         * to enter a synchronized block/method or
         * reenter a synchronized block/method after calling
         * {@link Object#wait() Object.wait}.
         */
        BLOCKED,

        /**
         * Thread state for a waiting thread.
         * A thread is in the waiting state due to calling one of the
         * following methods:
         * <ul>
         *   <li>{@link Object#wait() Object.wait} with no timeout</li>
         *   <li>{@link #join() Thread.join} with no timeout</li>
         *   <li>{@link LockSupport#park() LockSupport.park}</li>
         * </ul>
         *
         * <p>A thread in the waiting state is waiting for another thread to
         * perform a particular action.
         *
         * For example, a thread that has called <tt>Object.wait()</tt>
         * on an object is waiting for another thread to call
         * <tt>Object.notify()</tt> or <tt>Object.notifyAll()</tt> on
         * that object. A thread that has called <tt>Thread.join()</tt>
         * is waiting for a specified thread to terminate.
         */
        WAITING,

        /**
         * Thread state for a waiting thread with a specified waiting time.
         * A thread is in the timed waiting state due to calling one of
         * the following methods with a specified positive waiting time:
         * <ul>
         *   <li>{@link #sleep Thread.sleep}</li>
         *   <li>{@link Object#wait(long) Object.wait} with timeout</li>
         *   <li>{@link #join(long) Thread.join} with timeout</li>
         *   <li>{@link LockSupport#parkNanos LockSupport.parkNanos}</li>
         *   <li>{@link LockSupport#parkUntil LockSupport.parkUntil}</li>
         * </ul>
         */
        TIMED_WAITING,

        /**
         * Thread state for a terminated thread.
         * The thread has completed execution.
         */
        TERMINATED;
    }
```



##### **2.多线程有几种实现方式？**

**2种方式；实际原理一致**

1. 继承Thread
2. 实现Runnable

##### ~~3.请谈谈什么是进程，什么是线程？~~



##### ~~4.启动线程是用start()方法还是run()方法？~~



##### 5.说说线程安全问题，什么实现线程安全，如何实现线程安全？



##### 6.sychronized和Lock的区别？



##### 7.sleep()和wait()的区别？



##### 8.深入分析ThreadLocal的实现原理？



##### 9.你看过AbstractQueuedSynchronizer源码阅读吗，请说说实现原理？



##### 10.谈谈对synchronized的偏向锁、轻量级锁、重量级锁的理解？



##### 11.通过三种方式实现生产者消费者模式？



##### 12.JVM层面分析sychronized如何保证线程安全的？



##### 13.JDK层面分析sychronized如何保证线程安全的？



##### 14.如何写一个线程安全的单例？



##### 15.通过AQS实现一个自定义的Lock？



##### 16.ThreadLocal什么时候会出现OOM的情况？为什么？



##### 17.为什么wait, notify 和 notifyAll这些方法不在thread类里面？



##### 18.你真的理解CountDownLatch与CyclicBarrier使用场景吗？



##### 19.出现死锁，如何排查定位问题？



##### 20.notify和notifyAll的区别？



##### 21.线程池启动线程submit和execute有什么不同？



##### 22.SimpleDateFormat是线程安全的吗？如何解决？



##### 23.请谈谈ConcurrentHashmap底层实现原理？



##### 24.使用synchronized修饰静态方法和非静态方法有什么区别？



##### 25.当一个线程进入一个对象的一个synchronized方法后,其它线程是否可进入此对象的其方法？

不能，一个对象的一个synchronized方法只能由一个线程访问。 

对象的synchronized方法不能进入了，但它的其他非synchronized方法还是可以访问的。



##### 26.线程池的原理，为什么要创建线程池？创建线程池的方式？



##### 27.创建线程池有哪几个核心参数？ 如何合理配置线程池的大小？



##### 28.synchronized修饰的静态方法和非静态方法有什么区别？



#### **Java Web**

什么是Servlet，Servlet生命周期方法？

什么Session和Cookie，它们之间有什么联系？

Http1.0和Http1.1的区别是什么？

拦截器与过滤器的区别？



#### JVM面试题

VM内存区域如何划分？

JVM堆中对象是如何创建的?

JVM对象的结构？

JVM垃圾回收-如何判断对象是否是垃圾对象？

JVM垃圾回收算法有哪些？

JVM垃圾收集器有哪些？

JVM内存是如何分配的？

从一道面试题分析类的加载过程？

JVM双亲委派机制？

JVM可以作为GC Root的对象有哪些？

请写出几段可以导致内存溢出、内存泄漏、栈溢出的代码？

哪些情况会导致Full GC？

频繁GC问题或内存溢出问题，如何定位？



#### SQL性能优化

数据库三范式是什么？

数据库的事务、ACID及隔离级别？

不考虑事务的隔离性，容易产生哪三种情况？

数据库连接池原理？

什么是B-Tree？

什么是B+Tree？

MySQL数据库索引结构？

什么是索引？什么条件适合建立索引？什么条件不适合建立索引？

索引失效的原因有哪些？如何优化避免索引失效？

MySQL如何启动慢查询日志？

MySQL如何使用show Profile进行SQL分析？

一条执行慢的SQL如何进行优化，如何通过Explain+SQL分析性能？

什么是行锁、表锁、读锁、写锁，说说它们各自的特性？

什么情况下行锁变表锁？

什么情况下会出现间隙锁？

谈谈你对MySQL的in和exists用法的理解？

MySQL的数据库引擎有哪些，如何确定在项目中要是用的存储引擎？

count(*)、count(列名)和count(1)的区别？

union和union all的区别



#### Spring框架

Spring的IOC和AOP机制？

Spring中Autowired和Resource关键字的区别？

依赖注入的方式有几种，各是什么?

Spring容器对Bean组件是如何管理的？

Spring容器如何创建？

Spring事务分类？

Spring事务的传播特性？

Spring事务的隔离级别？

Spring的通知类型有哪些？



#### SpringMVC框架

SpringMVC完整工作流程，熟读源码流程？

SpringMVC如何处理JSON数据？

SpringMVC拦截器原理，如何自定义拦截器？

SpringMVC如何将请求映射定位到方法上面？结合源码阐述？

SpringMVC常见注解有哪些？

SpringMVC容器和Spring容器的区别？

SpringMVC的控制器是不是单例模式,如果是,有什么问题,怎么解决？



#### MyBatis框架

MyBatis中#和$的区别？

MyBatis一级缓存原理以及失效情况？

MyBatis二级缓存的使用？

MyBatis拦截器原理？

看过MyBatis源码吗，请说说它的工作流程？



#### Java高级部分

Dubbo负载均衡策略？

Dubbo中Zookeeper做注册中心，如果注册中心集群都挂掉，发布者和订阅者之间还能通信么？

Dubbo完整的一次调用链路介绍？

请说说SpringBoot自动装配原理？

有用过SpringCloud吗，请说说SpringCloud和Dubbo有什么不一样？

什么是WebService，如何基于WebService开发接口？

谈谈项目中分布式事务应用场景？

使用Redis如何实现分布式锁？

请谈谈单点登录原理？

Tomcat如何优化？

后台系统怎么防止请求重复提交？

Linux常见命令有哪些？

请说说什么是Maven的依赖、继承以及聚合？

Git暂存区和工作区的区别？

Git如何创建、回退以及撤销版本？

常见的设计模式有哪些





#### CAP和BASE理论的引出

对于本地事务处理或者是集中式的事务处理系统，依照传统的ACID特性即可保证数据的严格一致性。

可是对于分布式事务，传统的单机事务模型已经无法胜任。如果我们期望实现一套严格满足ACID特性的分布式事务，很可能出现的情况就是在系统的可用性和严格一致性之间出现冲突。

因此，在可用性和一致性之间永远无法存在一个两全其美的方案，于是如何构建一个兼顾可用性和一致性的分布式系统成为了无数工程师探讨的难题，出现了诸如CAP和BASE这样的分布式系统经典理论。

**CAP定理**

CAP定理告诉我们，**分布式系统不可能同时满足一致性（C：Consistency）、可用性（A：Availability）和分区容错性（P：Partition Tolerance），最多只能同时满足其中两项。**

**一、一致性（C：Consistency）**

一致性指的是多个数据副本是否能保持一致的特性，在一致性的条件下，系统在执行数据更新操作之后能够从一致性状态转移到另一个一致性状态。

对系统的一个数据更新成功之后，如果所有用户都能够读取到最新的值，该系统就被认为具有**强一致性**。

**二、可用性（A：Availability）**

可用性指分布式系统在面对各种异常时可以提供正常服务的能力，可以用系统可用时间占总时间的比值来衡量，4 个 9 的可用性表示系统 99.99% 的时间是可用的。

在可用性条件下，要求系统提供的服务一直处于可用的状态，对于用户的每一个操作请求总是能够在有限的时间内返回结果。

**三、分区容错性（P：Partition Tolerance）**

网络分区指分布式系统中的节点被划分为多个区域，每个区域内部可以通信，但是区域之间无法通信。

在分区容错性条件下，分布式系统在遇到任何网络分区故障的时候，仍然需要能对外提供一致性和可用性的服务，除非是整个网络环境都发生了故障。

**四、权衡**

由上面我们可以看出，在分布式系统中，分区容错性必不可少，因为需要总是假设网络是不可靠的。因此，CAP 理论实际上是要在可用性和一致性之间做权衡。

可用性和一致性往往是冲突的，很难使它们同时满足。在多个节点之间进行数据同步时:

**为了保证一致性（CP），不能访问未同步完成的节点，也就失去了部分可用性；**

**为了保证可用性（AP），允许读取所有节点的数据，但是数据可能不一致。**



**BASE理论**

BASE 是**基本可用（Basically Available）、软状态（Soft State）和最终一致性（Eventually Consistent）三个短语**的缩写。

BASE 理论是对 CAP 中**一致性和可用性权衡的结果**，它的核心思想是：**即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性。**

**基本可用**

指分布式系统在出现故障的时候，保证核心可用，允许损失部分可用性。

例如，电商在做促销时，为了保证购物系统的稳定性，部分消费者可能会被引导到一个降级的页面。

**软状态**

指允许系统中的数据存在中间状态，并认为该中间状态不会影响系统整体可用性，即允许系统不同节点的数据副本之间进行同步的过程存在时延。

**最终一致性**

最终一致性强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能达到一致的状态。

**ACID 要求强一致性，通常运用在传统的数据库系统上**。而 **BASE 要求最终一致性，通过牺牲强一致性来达到可用性，通常运用在大型分布式系统中。**

在实际的分布式场景中，不同业务单元和组件对一致性的要求是不同的，因此 ACID 和 BASE 往往会结合在一起使用



#### 谈谈反设计模式





#### java基础以及多个“比较*

##### **1.Collections.sort排序内部原理**

在Java 6中Arrays.sort()和Collections.sort()使用的是MergeSort，而在Java 7中，内部实现换成了TimSort，其对对象间比较的实现要求更加严格



####Redis

##### redis 是什么？都有哪些使用场景？

NoSQL(NoSQL = Not Only SQL )，意即“不仅仅是SQL”，

**Redis:REmote DIctionary Server(远程字典服务器)**
是完全开源免费的，用C语言编写的，遵守BSD协议，
是一个高性能的(key/value)分布式内存数据库，基于内存运行
并支持持久化的NoSQL数据库，是当前最热门的NoSql数据库之一,也被人们称为数据结构服务器。
优点：

**Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用。RDB和AOF**
**Redis不仅仅支持简单的key-value类型的数据，提供5种数据类型（string，list，hash，set，zset）**
Redis支持数据的备份，即master-slave模式的数据备份

**应用场景：**

1. **内存存储和持久化：redis支持异步将内存中的数据写到硬盘上，同时不影响继续服务**
2. **取最新N个数据的操作**，如：可以将最新的10条评论的ID放在Redis的List集合里面
3. 模拟类似于HttpSession这种需要设定过期时间的功能；**session集中化**
4. **发布、订阅消息系统**
5. 定时器、计数器
6. 分布式锁（setnx、watch）
7. 限时业务的运用
8. 热点数据的缓存
9. 延时操作

##### redis 有哪些功能？

基于本机内存的缓存、服务端Redis、持久化、哨兵（Sentinel）和复制（Replication）、集群（Cluster）、

发布/订阅、慢查询、Lua支持

##### redis 和 memecache 有什么区别？

1)、存储方式
 Memecache把数据全部存在内存之中，断电后会挂掉，数据不能超过内存大小。
 Redis有部份存在硬盘上，这样能保证数据的持久性。
 2)、数据支持类型
 Memcache对数据类型支持相对简单。
 Redis有复杂的数据类型。
 3)、使用底层模型不同
 它们之间底层实现方式 以及与客户端之间通信的应用协议不一样。
 Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。
 4），value大小
 redis最大可以达到1GB，而memcache只有1MB

##### redis 为什么是单线程的？

以前一直有个误区，以为：高性能服务器  一定是 多线程来实现的 

原因很简单因为误区二导致的： 多线程 一定比 单线程  效率高。其实不然。

在说这个事前希望大家都能对  CPU 、 内存 、 硬盘的速度都有了解了，这样可能理解得更深刻一点，不了解的朋友点：[CPU到底比内存跟硬盘快多少](http://blog.csdn.net/world6/article/details/79375690)

[redis](https://cloud.tencent.com/product/crs?from=10680) 核心就是 如果我的数据全都在内存里，我单线程的去操作 就是效率最高的，为什么呢，因为多线程的本质就是 CPU 模拟出来多个线程的情况，这种模拟出来的情况就有一个代价，就是上下文的切换，对于一个内存的系统来说，它没有上下文的切换就是效率最高的。redis 用 单个CPU 绑定一块内存的数据，然后针对这块内存的数据进行多次读写的时候，都是在一个CPU上完成的，所以它是单线程处理这个事。在内存的情况下，这个方案就是最佳方案  —— 阿里 沈询 

因为一次CPU上下文的切换大概在 1500ns 左右。

从内存中读取 1MB 的连续数据，耗时大约为 250us，假设1MB的数据由多个线程读取了1000次，那么就有1000次时间上下文的切换，

那么就有1500ns * 1000 = 1500us ，我单线程的读完1MB数据才250us ,你光时间上下文的切换就用了1500us了，我还不算你每次读一点数据 的时间，

那什么时候用多线程的方案呢？

答案是：下层的存储等慢速的情况。比如磁盘

内存是一个 IOPS 非常高的系统，因为我想申请一块内存就申请一块内存，销毁一块内存我就销毁一块内存，内存的申请和销毁是很容易的。而且内存是可以动态的申请大小的。

磁盘的特性是：IPOS很低很低，但吞吐量很高。这就意味着，大量的读写操作都必须攒到一起，再提交到磁盘的时候，性能最高。为什么呢？

如果我有一个事务组的操作（就是几个已经分开了的事务请求，比如写读写读写，这么五个操作在一起），在内存中，因为IOPS非常高，我可以一个一个的完成，但是如果在磁盘中也有这种请求方式的话，

我第一个写操作是这样完成的：我先在硬盘中寻址，大概花费10ms，然后我读一个数据可能花费1ms然后我再运算（忽略不计），再写回硬盘又是10ms ，总共21ms

第二个操作去读花了10ms, 第三个又是写花费了21ms ,然后我再读10ms, 写21ms ，五个请求总共花费83ms，这还是最理想的情况下，这如果在内存中，大概1ms不到。

所以对于磁盘来说，它吞吐量这么大，那最好的方案肯定是我将N个请求一起放在一个buff里，然后一起去提交。

方法就是用异步：将请求和处理的线程不绑定，请求的线程将请求放在一个buff里，然后等buff快满了，处理的线程再去处理这个buff。然后由这个buff 统一的去写入磁盘，或者读磁盘，这样效率就是最高。 java里的 IO不就是这么干的么~

对于慢速设备，这种处理方式就是最佳的，慢速设备有磁盘，网络 ，SSD 等等，

 多线程 ，异步的方式处理这些问题非常常见，大名鼎鼎的netty 就是这么干的。

终于把 redis 为什么是单线程说清楚了，把什么时候用单线程跟多线程也说清楚了，其实也是些很简单的东西，只是基础不好的时候，就真的尴尬。。。。 

补一发大师语录：来说说，为何单核cpu绑定一块内存效率最高

“我们不能任由操作系统[负载均衡](https://cloud.tencent.com/product/clb?from=10680)，因为我们自己更了解自己的程序，所以我们可以手动地为其分配CPU核，而不会过多地占用CPU”，默认情况下单线程在进行系统调用的时候会随机使用CPU内核，为了优化Redis，我们可以使用工具为单线程绑定固定的CPU内核，减少不必要的性能损耗！

##### 什么是缓存穿透？怎么解决？

**一．缓存穿透：**

     缓存穿透是指查询一个一定不存在的数据，由于缓存是不命中时需要从数据库查询，查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到数据库去查询，造成缓存穿透。
    
     解决办法：
    
     1.布隆过滤

  **对所有可能查询的参数以hash形式存储，在控制层先进行校验，不符合则丢弃**。还有最常见的则是**采用布隆过滤器**，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。

  补充:

      Bloom filter

  适用范围：**可以用来实现数据字典，进行数据的判重，或者集合求交集**

  基本原理及要点：对于原理来说很简单，位数组+k个独立hash函数。将hash函数对应的值的位数组置1，查找时如果发现所有hash函数对应位都是1说明存在，很明显这个过程并不保证查找的结果是100%正确的。同时也不支持删除一个已经插入的关键字，因为该关键字对应的位会牵动到其他的关键字。所以一个简单的改进就是counting Bloom filter，用一个counter数组代替位数组，就可以支持删除了。添加时增加计数器，删除时减少计数器。

     2. 缓存空对象. 将 null 变成一个值.

  也可以采用一个更为简单粗暴的方法，如果一个查询返回的数据为空（不管是数 据不存在，还是系统故障），我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。

 缓存空对象会有两个问题：

 第一，空值做了缓存，意味着缓存层中存了更多的键，需要更多的内存空间 ( 如果是攻击，问题更严重 )，比较有效的方法是针对这类数据设置一个较短的过期时间，让其自动剔除。

 第二，缓存层和存储层的数据会有一段时间窗口的不一致，可能会对业务有一定影响。例如过期时间设置为 5分钟，如果此时存储层添加了这个数据，那此段时间就会出现缓存层和存储层数据的不一致，此时可以利用消息系统或者其他方式清除掉缓存层中的空对象。

二.缓存雪崩

    如果缓存集中在一段时间内失效，发生大量的缓存穿透，所有的查询都落在数据库上，造成了缓存雪崩。
    
    这个没有完美解决办法，但可以分析用户行为，尽量让失效时间点均匀分布。大多数系统设计者考虑用加锁或者队列的方式保证缓存的单线程（进程）写，从而避免失效时大量的并发请求落到底层存储系统上。

 解决方法

   1. **加锁排队. 限流-- 限流算法. 1.计数 2.滑动窗口 3.  令牌桶Token Bucket 4.漏桶 leaky bucket [1]**

 在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待。

 业界比较常用的做法，是使用mutex。简单地来说，就是在缓存失效的时候（判断拿出来的值为空），不是立即去load db，而是先使用缓存工具的某些带成功操作返回值的操作（比如Redis的SETNX或者Memcache的ADD）去set一个mutex key，当操作返回成功时，再进行load db的操作并回设缓存；否则，就重试整个get缓存的方法。

SETNX，是「SET if Not eXists」的缩写，也就是只有不存在的时候才设置，可以利用它来实现锁的效果。

     2.数据预热

  可以通过缓存reload机制，预先去更新缓存，再即将发生大并发访问前手动触发加载缓存不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀

  3.做二级缓存，或者双缓存策略。

     A1为原始缓存，A2为拷贝缓存，A1失效时，可以访问A2，A1缓存失效时间设置为短期，A2设置为长期。

   4.缓存永远不过期

 这里的“永远不过期”包含两层意思：

    (1) 从缓存上看，确实没有设置过期时间，这就保证了，不会出现热点key过期问题，也就是“物理”不过期。
    
     (2) 从功能上看，如果不过期，那不就成静态的了吗？所以我们把过期时间存在key对应的value里，如果发现要过期了，通过一个后台的异步线程进行缓存的构建，也就是“逻辑”过期.

 从实战看，这种方法对于性能非常友好，唯一不足的就是构建缓存时候，其余线程(非构建缓存的线程)可能访问的是老数据，但是对于一般的互联网功能来说这个还是可以忍受。


##### ~~redis 支持的数据类型有哪些？~~

五种

##### redis 支持的 java 客户端都有哪些？

Redisson,Jedis，lettuce等等，官方推荐使用Redisson

##### jedis 和 redisson 有哪些区别？

Jedis 和 Redisson 都是Java中对Redis操作的封装。Jedis 只是简单的封装了 Redis 的API库，可以看作是Redis客户端，它的方法和Redis 的命令很类似。Redisson 不仅封装了 redis ，还封装了对更多数据结构的支持，以及锁等功能，相比于Jedis 更加大。但Jedis相比于Redisson 更原生一些，更灵活。



Redisson是一个在Redis的基础上实现的Java驻内存数据网格（In-Memory Data Grid）。它不仅提供了一系列的分布式的Java常用对象，还提供了许多分布式服务。其中包括Bitset, Set, MultiMap, SortedSet, Map, List, Queue, BlockingQueue, Deque, BlockingDeque, Semaphore, Lock, AtomicLong, CountDownLatch, Publish/Subscribe, Bloom filter, Remote service, Spring cache, Executor service, Live Object service, Scheduler service。Redisson提供了使用Redis的最简单和最便捷的方法。Redisson的宗旨是促进使用者对Redis的关注分离（Separation of Concern），从而让使用者能够将精力更集中地放在处理业务逻辑上



##### 怎么保证缓存和数据库数据的一致性？

淘汰缓存还是更新缓存？

**选择淘汰缓存**

原因：数据可能为简单数据，也可能为较复杂的数据，复杂数据进行缓存的更新操作，成本较高，因此一般推荐淘汰缓存

先淘汰缓存还是先更新数据库？

**选择先\**淘汰缓存\**，再\**更新数据库\****

原因：假如先更新数据库，再淘汰缓存，假如缓存淘汰失败，那么后面的请求都会得到脏数据，直至缓存过期。假如先淘汰缓存再更新数据库，如果数据库更新失败，只会产生一次缓存miss，相比较而言，后者对业务影响更小一点。

延时双删策略

如下场景：同时有一个请求A进行更新操作，另一个请求B进行查询操作。
（1）请求A进行写操作，删除缓存
（2）请求B查询发现缓存不存在
（3）请求B去数据库查询得到旧值
（4）请求B将旧值写入缓存
（5）请求A将新值写入数据库

次数便出现了数据不一致问题。采用延时双删策略得以解决

```c
public void write(String key,Object data){
    redisUtils.del(key);
    db.update(data);
    Thread.Sleep(100);
    redisUtils.del(key);
}
```

这么做，可以将1秒内所造成的缓存脏数据，再次删除。这个时间设定可根据俄业务场景进行一个调节。

数据库读写分离的场景

两个请求，一个请求A进行更新操作，另一个请求B进行查询操作。

（1）请求A进行写操作，删除缓存
（2）请求A将数据写入数据库了，
（3）请求B查询缓存发现，缓存没有值
（4）请求B去从库查询，这时，还没有完成主从同步，因此查询到的是旧值
（5）请求B将旧值写入缓存
（6）数据库完成主从同步，从库变为新值

依旧采用延时双删策略解决此问题



##### ~~redis 持久化有几种方式？~~

AOF

RDB

##### redis 怎么实现分布式锁？

分布式锁常见的三种实现方式：

1. 数据库乐观锁；
2. 基于Redis的分布式锁；
3. 基于ZooKeeper的分布式锁。

本地面试考点是，你对Redis使用熟悉吗？Redis中是如何实现分布式锁的。

**要点**

Redis要实现分布式锁，以下条件应该得到满足

**互斥性**

- 在任意时刻，只有一个客户端能持有锁。

**不能死锁**

- 客户端在持有锁的期间崩溃而没有主动解锁，也能保证后续其他客户端能加锁。

**容错性**

- 只要大部分的Redis节点正常运行，客户端就可以加锁和解锁。

**实现**

可以直接通过 `set key value px milliseconds nx` 命令实现加锁， 通过Lua脚本实现解锁。



watch

setnx



##### redis 分布式锁有什么缺陷？

Redis 分布式锁不能解决超时的问题，分布式锁有一个超时时间，程序的执行如果超出了锁的超时时间就会出现问题。



##### redis 如何做内存优化？

1、缩减键值对象

　　缩减键（key）和值（value）的长度，

- key长度：如在设计键时，在完整描述业务情况下，键值越短越好。
- value长度：值对象缩减比较复杂，常见需求是把业务对象序列化成二进制数组放入Redis。首先应该在业务上精简业务对象，去掉不必要的属性避免存储无效数据。其次在序列化工具选择上，应该选择更高效的序列化工具来降低字节数组大小。以JAVA为例，内置的序列化方式无论从速度还是压缩比都不尽如人意，这时可以选择更高效的序列化工具，如: protostuff，kryo等，下图是JAVA常见序列化工具空间压缩对比。

2、共享对象池

　　对象共享池指Redis内部维护[0-9999]的整数对象池。创建大量的整数类型redisObject存在内存开销，每个redisObject内部结构至少占16字节，甚至超过了整数自身空间消耗。所以Redis内存维护一个[0-9999]的整数对象池，用于节约内存。 除了整数值对象，其他类型如list,hash,set,zset内部元素也可以使用整数对象池。因此开发中在满足需求的前提下，尽量使用整数对象以节省内存。

3、字符串优化

4、编码优化

5、控制key的数量

##### redis 淘汰策略有哪些？

1）voltile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰
2）volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰
3）volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰
4）allkeys-lru：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰
5）allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰
6）no-enviction（驱逐）：禁止驱逐数据

##### redis 常见的性能问题有哪些？该如何解决？

